<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>闫大雨的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="个人博客">
<meta name="keywords" content="闫大雨，前端，博客">
<meta property="og:type" content="website">
<meta property="og:title" content="闫大雨的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="闫大雨的博客">
<meta property="og:description" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="闫大雨的博客">
<meta name="twitter:description" content="个人博客">
  
    <link rel="alternate" href="/atom.xml" title="闫大雨的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">闫大雨的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-原-Es6" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/原-Es6/" class="article-date">
  <time datetime="2019-01-02T13:23:51.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/原-Es6/">[原]Es6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>let声明变量</strong></p>
<ol>
<li>声明不会提升</li>
<li>不能重复声明（当前作用域下不能有相同变量名），会报错</li>
<li>变量会捆绑在当前的语句块中，也就是说只在当前块级作用域下生效</li>
</ol>
<p><strong>const声明常量</strong></p>
<ol>
<li>声明不会提升</li>
<li>不能重复声明，会报错</li>
<li>在声明常量时，必须要赋值，否则会报错</li>
<li>一经赋值不可修改</li>
</ol>
<p><strong>函数参数的默认值</strong></p>
<p><code>function(color = ‘red’){}</code></p>
<p>red为color的默认值</p>
<p><strong>箭头函数</strong></p>
<p><code>var max = function(){}</code></p>
<p><code>var max = () =&gt; {}</code>    这行代码等价与上面的代码</p>
<p>当代码简洁时，可以把大括号去掉简写为一行</p>
<p>eg：<code>var max = (x,y) =&gt; x&gt;y?x:y;</code></p>
<p>=&gt; 后面的代码为return的值，但不能写return</p>
<p>如果函数的参数不止一个或没有，要用小括号包着，如果只有一个参数，可以省略括号。</p>
<p>箭头函数中没有this，如果使用this是指向window的</p>
<p><strong>剩余操作符 …</strong></p>
<p>我们可以在形参名前加上…来让它接受剩余的参数，当不确定实参个数时，这是个很好的选择。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b,…others</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//a=1,b=2,others就等于一个数组，里面包含所有剩下的实参，也就是[3,4,5,6,7]</span></span><br></pre></td></tr></table></figure>
<p><strong>展开操作符…</strong></p>
<p>我们可以在数组名前加上展开操作符，那么他就会显示数组中的各个元素</p>
<p>eg:  <code>let arr1 = [1,2,3]     console.log(…arr1)</code></p>
<p>控制台会打印1,2,3</p>
<p>我们也可以使用这个操作符来复制/合并数组</p>
<p>复制：let arr2 = […arr1]</p>
<p>合并：let arr2 = […arr1,4,5]</p>
<p><strong>模板字面量</strong></p>
<p>使用模板字面量来定义字符串，可以使用${}在字符串中插入内容，在括号中可写变量或表达式</p>
<p>并且在模板字面量中换行，会保留格式，换行和tab键都会放在字符串中</p>
<p><code>var str = `</code> `</p>
<p><strong>对象的属性简写</strong></p>
<p>当属性值和属性名相同时，可简写为一个变量名<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'李四'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">name</span><br><span class="line"><span class="comment">//这里的name值为李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>数组解构</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors=  [ <span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> [firstC,secC,thirdC] = colors;</span><br><span class="line"><span class="comment">// 上面的变量的值按顺序依次为数组中的颜色</span></span><br></pre></td></tr></table></figure></p>
<p>当为变量重新赋值时，只需将let 去掉即可。</p>
<p>为变量设置默认值，与函数形参默认值方法相同。</p>
<p><strong>嵌套数组解构</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors=  [ <span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,[<span class="string">'violet'</span>,<span class="string">'white'</span>]];</span><br><span class="line"><span class="keyword">let</span> [firstC,secC,thirdC,[,lastC]] = colors;</span><br></pre></td></tr></table></figure></p>
<p><strong>对象解构</strong><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1= &#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = obj1;</span><br></pre></td></tr></table></figure></p>
<p>与数组解构不同的是,上面这种方法只能当变量名和对象的属性名相同使可以使用，如果要为非同名的变量赋值，要写为以下的方式<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myName,<span class="attr">age</span>:myAge&#125; = obj1;</span><br></pre></td></tr></table></figure></p>
<p>前面的是对象中的属性名，后面的为我们设置的变量名，相当于为变量指明要从哪里找值。</p>
<p>默认值：与函数形参的默认值的传值方式相同</p>
<p>为变量重新赋值：因为JavaScript不允许赋值操作符左边出现花括号，所以我们要将整个赋值语句用小括号包裹起来，将赋值语句变为一个表达式。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;<span class="attr">name</span>:myName,<span class="attr">age</span>:myAge&#125; = obj1;)</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/原-Es6/" data-id="cjqghu75o0001tsctfbz6grgv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Es6/">Es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-转-Evevt-Loop-事件循环" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/02/转-Evevt-Loop-事件循环/" class="article-date">
  <time datetime="2019-01-02T12:26:40.000Z" itemprop="datePublished">2019-01-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/02/转-Evevt-Loop-事件循环/">[转]Evevt Loop 事件循环</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>今天在看es6的promise的时候，看了一个很有意思的面试题，牵扯到了setTimeout的执行顺序，总结一下</strong></p>
<p><strong>贴一下面试题的链接</strong> Excuse me？这个前端面试在搞事！ - Liril的文章 - 知乎<a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25407758</a></p>
<p><img src="/images/EventLoop.png" alt="事件循环"></p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p>
<p><strong>setTimeout</strong></p>
<blockquote>
<p>如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立即执行，相反会把它放到队列中去，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。（setTimeout和setInterval经常有不守时的时候）。</p>
</blockquote>
<blockquote>
<p>setTimeout并不是真正的异步操作，只是把想执行的代码放到UI队列中，在未来执行</p>
</blockquote>
<p><strong>Es6中的Promise，里面的函数是直接执行的，比setTimeout执行的早</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/02/转-Evevt-Loop-事件循环/" data-id="cjqghu766000ftsctiadni9t7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-jQuery总结" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/21/原-jQuery总结/" class="article-date">
  <time datetime="2018-12-21T12:54:42.000Z" itemprop="datePublished">2018-12-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/21/原-jQuery总结/">[原]jQuery总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="jQuery入口函数"><a href="#jQuery入口函数" class="headerlink" title="jQuery入口函数"></a><a id="jQuery_0"></a>jQuery入口函数</h2><p><code>$(document).ready(function(){})</code></p>
<p><code>$(function(){})</code></p>
<h2 id="js入口函数与jQ入口函数的区别"><a href="#js入口函数与jQ入口函数的区别" class="headerlink" title="js入口函数与jQ入口函数的区别"></a><a id="jsjQ_4"></a>js入口函数与jQ入口函数的区别</h2><p>js函数的入口函数比jq慢,因为js的入口函数会等待页面加载完成,并且外部资源也加载完成后才会执行,但jq</p>
<p>的入口函数等待页面加载完成后就会执行。</p>
<p>js入口函数只能执行一次,会产生覆盖,但jq的可以多次使用</p>
<h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a><a id="_9"></a>隐式迭代</h2><p>jQuery有隐式迭代的特性,会自动的遍历,设置操作时会给选择到所有的对象都设置上相同的值。在获取值时,如果选择的对象中有多个元素,就只会获取到第一个的值,因为隐式迭代会让jq认为所有的值都为相同的。</p>
<h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a><a id="_12"></a>链式编程</h2><p>jq的方法都会返回一个对象,所以我们可以一直调用下去。但返回的如果不是当前对象,就不能链式下去。</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a><a id="_15"></a>选择器</h2><p><strong>基本选择器</strong></p>
<ol>
<li>ID选择器</li>
<li>类选择器</li>
<li>标签选择器</li>
<li>并列选择器    <code>$(&#39;p,span&#39;)</code></li>
<li>交集选择器    <code>$(&#39;p.box&#39;)</code></li>
</ol>
<p><strong>层次选择器</strong></p>
<ol>
<li>直接子级选择器</li>
<li>后代选择器</li>
<li>后面所有同级  $(“p~span”)</li>
<li>后面紧挨着的同级  $(“p+span”)</li>
</ol>
<p><strong>筛选选择器（方法）</strong>   ()里面也可以加选择器</p>
<p><code>.first()</code>                   第一个元素</p>
<p><code>.last()</code>                   最后一个</p>
<p><code>.children()</code>            相当于子级选择器</p>
<p><code>.find()</code>                   相当于后代选择器</p>
<p><code>.parent()</code>               父元素</p>
<p><code>.parents()</code>             祖先元素</p>
<p><code>.next()</code>                 下一个同级</p>
<p><code>.nextAll()</code>             下面所有的同级</p>
<p><code>.nextUntil()</code>            往下找,直到选择器为止不包括选择器（相当与一个区间）</p>
<p><code>.prev()</code>                 上一个</p>
<p><code></code>.prevAll() `             上面所有的同级</p>
<p><code>.prevUntil()</code>          往上找,直到选择器,不包含选择器</p>
<p><code>.siblings()</code>            除自身外所有的同级</p>
<p><code>.slice()</code>                  同数组方法</p>
<p><code>.filter()</code>                  选取满足选择器的元素</p>
<p><code>.not()</code>                    选取不满足选择器的元素</p>
<p><code>.has()</code>                   选取一个元素中有子元素满足此选择器</p>
<p><code>.is()</code>                      判断是否有此元素,如果一个有返回true,如果有多个,返回集合</p>
<p><code>.closest()</code>             从自身找距离自己最近的元素</p>
<p><code>.offsetParent()</code>     距离自己最近的定位祖先元素</p>
<p><code>.eq(index)</code>            选取指定下标的元素         .get(index)方法与此相同,但get()返回的是DOM对象,所以也可以用来将jq对</p>
<p>象转为DOM对象  ,$(dom对象)这种方法可以转为jq对象</p>
<p><strong>过滤选择器</strong></p>
<p><code>:first</code>              第一个</p>
<p><code>:last</code>               最后一个</p>
<p><code>:even</code>             偶数个</p>
<p><code>:odd</code>               奇数个</p>
<p><code>:gt(index)</code>        大于索引的</p>
<p><code>:lt(index)</code>         小于索引的</p>
<p><code>:contains()</code>     选取内容满足选择器的</p>
<p><code>:not</code>               不满足选择器的</p>
<p><code>:visible</code>          可见的元素</p>
<p><code>:hide</code>              隐藏的元素</p>
<p><code>:parent</code>           非空元素</p>
<p><code>:empty</code>         空元素</p>
<p><code>:has()</code>           选择包含有选择器的元素</p>
<p><code>:animate</code>        选择正在应用动画状态的元素</p>
<p><code>:target</code>           选择锚链接的目标位置</p>
<p><code>:button</code></p>
<p><code>:checked</code></p>
<p><code>:selecte</code></p>
<p><code>:disable</code></p>
<p><code>:enabled</code></p>
<p>所有css3的子元素选择器,属性选择器,这里就不过多写了(nth-child等)</p>
<p><strong>使用上下文获取元素</strong></p>
<p><code>$(“p”,&quot;#box&quot;)</code>   从#box下获取p元素</p>
<h2 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a><a id="_80"></a>操作样式</h2><p><strong>css()</strong></p>
<p>传一个参是获取样式值</p>
<p>传一个属性一个值是修改或添加</p>
<p>操作多个可以传对象</p>
<p><strong>操作class</strong></p>
<p><code>.addClass()</code>   添加类</p>
<p><code>.removeClass()</code> 移除类</p>
<p><code>.hasClass()</code>   判断是否有这个类</p>
<p><code>.toggleClass()</code>  切换类,如果有则删除,如果没有则加上</p>
<h2 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a><a id="_91"></a>操作属性</h2><p><strong>attr()</strong></p>
<p>与css的传参方式相同</p>
<p><code>removeAttr()</code>  删除属性</p>
<p><strong>prop()</strong></p>
<p>操作一些属性值为布尔值的属性,例如”<code>checked</code>,<code>disabled</code>等”</p>
<p><code>removeProp()</code>  删除属性</p>
<p><strong>data()</strong></p>
<p>操作自定义属性值</p>
<p><code>removeData()</code>   删除属性</p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a><a id="_102"></a>动画</h2><p><code>show()</code>和<code>hide()</code>   显示和隐藏    第一个参数是动画执行时间,第二个回调函数</p>
<p>slideDown()<code>,</code>slideUp()<code>,</code>slideToggle()`    划入滑出和切换</p>
<p><code>fadeIn()</code>,<code>fadeOut()</code>,<code>fadeToggle()</code>       渐入,渐出和切换（改变透明度）</p>
<p><code>animated(property,执行时间,执行效果(swing/linear),回调函数)</code></p>
<p><strong>动画队列</strong></p>
<p>jq会把动画储存到动画队列中,动画会按照顺序执行,不会丢失。但如果多次快速触发动画,动画执行需要一定时间,当不触发动画时,动画依然会执行,一直等到动画队列结束,为了解决这个问题我们可以使用 <code>stop()</code>方法</p>
<p><code>stop()</code>方法要在动画前调用,当触发动画时,先停止之前动画,再执行动画效果。</p>
<p><code>stop()</code>的方法有两个参数,第一个为是否清除动画队列,第二个为是否跳到动画的最终效果,一般情况下我们不会使用这两个参数。</p>
<p><code>delay(延迟时间,[队列名称])</code>   推迟动画队列之后的项目</p>
<h2 id="节点操作（增删改复制）"><a href="#节点操作（增删改复制）" class="headerlink" title="节点操作（增删改复制）"></a><a id="_113"></a>节点操作（增删改复制）</h2><p>创建: <code>$()</code></p>
<p>添加: <code>append()</code>      添加到目标元素的最后面（作为子元素）    也可以把想要创建的元素直接写在括号中,会先创建后添加</p>
<p><code>appendTo()</code>   与上的不同在于:目标元素写在括号中</p>
<p><code>prepend ()</code>     添加到目标元素的子元素的最前面</p>
<p><code>prependTo()</code>   与 appendTo同理</p>
<p><code>after()</code>              添加到目标元素的下面（作为兄弟元素）</p>
<p><code>innerAfter()</code></p>
<p><code>before()</code>               添加到目标元素的上面（作为兄弟元素）</p>
<p><code>innerbefore()</code></p>
<p>替换: <code>replaceWith()</code>     把目标元素替换为括号中的元素</p>
<p><code>replaceAll()</code>         用括号中的元素替换目标元素</p>
<p>克隆: <code>clone(true)</code>    深复制,不仅复制元素本身及其子元素,还会复制其绑定的事件和数据</p>
<p><code>clone(true)</code>    浅复制,只复制元素本身及其子元素,不会复制事件及数据</p>
<p><code>clone(true,false)</code>   复制元素本身及其子元素,但只复制父元素的事件及数据,不复制子元素的事件及数据</p>
<p>只要第一个参数为false,则不管第二个参数是什么,都为false</p>
<p>删除: <code></code>empty()`     清空元素,但元素自身依旧存在。会解除绑定事件</p>
<p><code>html(&#39;&#39;)</code>       清空元素,但元素自身依旧存在。但不会清空被清空的元素身上绑定的事件,会造成内存泄露。</p>
<p><code>detach()</code>     删除元素,自身也会被删除。但此方法不会删除元素身上绑定的事件数据</p>
<p><code>remove()</code>    删除元素,自身也会被删除。这个方法会删除绑定的事件数据。</p>
<p>删除的这两个方法,都不会删除jq对象,都会返回被删除的元素。我们可以在需要的时候重新添加到页面中。</p>
<h2 id="事件的注册触发解绑"><a href="#事件的注册触发解绑" class="headerlink" title="事件的注册触发解绑"></a><a id="_135"></a>事件的注册触发解绑</h2><p>注册: <code>on(事件类型,[事件委托的子元素],[传递给事件处理函数的数据,一般使用event,data来回去],事件处理函数)</code></p>
<p>触发: <code>trigger(事件类型)</code><br><code>解绑:</code>off(事件类型)`</p>
<h2 id="特殊属性操作（属性值-高宽）"><a href="#特殊属性操作（属性值-高宽）" class="headerlink" title="特殊属性操作（属性值,高宽）"></a><a id="_140"></a>特殊属性操作（属性值,高宽）</h2><p>获取或修改表单中的值:<code>val()</code>   传值为修改</p>
<p>获取或修改标签中的值:<code>text()</code>   <code>html()</code>  与innerText和innerHTML相同</p>
<p><code>width()</code>   实际宽度width,返回一个数字,传值可修改</p>
<p><code>height()</code>   实际高度</p>
<p><code>innerWidth()</code>  width+padding</p>
<p><code>innerHeight()</code>   height+padding</p>
<p><code>outerwidth()</code>    width+padding+border</p>
<p><code>outerHeight()</code>   height+padding+border</p>
<p><code>outerwidth(true)</code>    width+padding+border+margin</p>
<p><code>outerHeight(true)</code>   height+padding+border+margin</p>
<p><code>scrollTop()</code>     被卷曲出去的高度</p>
<p><code>scrollLeft()</code>     被卷曲出去的宽度</p>
<p><code>offset()</code>     获取元素距离document的距离,返回一个对象,里面有top和left的值。如果设置传一个对象,设置之后会给元素加相对定位,改变位置。</p>
<p><code>position()</code>    获取元素距离有定位父元素的距离,只可获取不能修改</p>
<h2 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a><a id="_156"></a>操作集合</h2><p><code>add()</code>   合并集合,括号内可以是选择器,标签,DOM对象,jq对象</p>
<p><code>addBack()</code>   将过滤后的对象与上一个合并</p>
<p><code>contents()</code>   获取对象中每一个元素的内容（文本,注释和标签）</p>
<p><code>index()</code>     返回当前元素在所有兄弟元素里面的索引</p>
<p><code>end()</code>   返回到上一次的操作</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="$冲突"></a><a id="_163"></a>$冲突</h2><p>当jq拿到控制权时,可以使用<code>onConflict()</code>来释放控制权,如果没有控制权可以使用jQuery来代替$</p>
<h2 id="包裹元素"><a href="#包裹元素" class="headerlink" title="包裹元素"></a><a id="_166"></a>包裹元素</h2><p><code>wrap()</code>   使用一个元素包裹每一个被选择到的对象</p>
<p><code>wrapAll()</code>   使用一个元素包裹所有被选择到的元素</p>
<p><code>wrapInner()</code>   使用指定标签包裹元素中的内容</p>
<p><code>unwrap()</code>    删除包裹该元素的元素,也就是父元素,如果括号内传了选择器,如果不满足此选择器,则不会被删除</p>
<h2 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a><a id="_172"></a>工具方法</h2><p><code>$.each(function(索引,属性){})</code>   遍历</p>
<p><code>$.each(function(属性名,属性值){})</code>   遍历</p>
<p>遍历对象时形参为属性名和属性值,数组或jq对象时,形参为索引和属性</p>
<p><code>$.extend(true/false,obj1,obj2)</code>  将第二个及其以后的对象合并到第一个  第一个值为true是深合并,会合并对象中的对象,false则不会。如果对象中的属性名有相同的,后面的会覆盖前面的。如果属性值出现undefined,则会被忽略。</p>
<p>可以用来复制对象   $.extent({},obj1)</p>
<p><code>$.greg(数组,function(属性,索引){})</code>           从数组中过滤出满足条件的元素,返回值为布尔值</p>
<p><code>$.merge(arr1,arr2)`</code>    把第二个数组合并到第一个,这个方法只能有两个参数</p>
<p><code>$.inArray(要找的元素,去哪个数组找,从索引几开始找(默认0))</code>     属性是否在数组中,是则返回索引,不是返回-1</p>
<p><code>$.map(数组/对象,function(元素/属性值,索引/属性名){})</code>    用指定函数处理对象或数组中的每一个元素,返回值作为数组或对象中的元素,并把结果封装为新的数组或对象,如果返回null/undefined,则不会被添加到数组或对象中</p>
<p><code>$.makeArray()</code>     把一个类似数组（有集合,下标）的对象转为数组</p>
<p><code>$.isArray()</code>     判断是否为数组</p>
<p><code>$.isPlainObject()</code>  判断是否为一个对象</p>
<p><code>$.isEmptyObject()</code>   判断是否为空对象</p>
<p><code>$.type()</code>    检测数据类型   与typeof()类似</p>
<p><code>toArray()</code>   将JQ对象转为数组</p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><a id="AJAX_189"></a>AJAX</h2><p><code>$().load(url,与请求一同发送的查询字符串键/值对集合,回调函数)</code>   从服务器加载数据,并把返回的数据放置到指定元素中</p>
<p><code>$().getScript(url,回调函数)</code>   使用get方式获取js类型的数据</p>
<p><code>$().getJSON(url,回调函数)</code>    使用get方式获取quJSON类型的数据</p>
<p><code>$().get(url,回调函数,期望返回数据的类型)</code>  使用get方式获取指定类型的数据   能接受数据的类型有5种:html,text,JSON,js,xml</p>
<p><code>$().post(url,提交的数据,回调函数,期望返回数据的类型)</code>  使用post方式提交数据</p>
<p><code>$().ajax(url,各种设置)/ $().ajax(各种设置)</code>    设置:url,data数据,dataType数据类型,timeout超时时间,method提交方式,global :true/false是否触发全局ajax事件处理程序,success回调函数,error回调,complete回调,beforeSend回调</p>
<p><code></code>$().ajaxsetup()`  设置下面的ajax请求的默认值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/21/原-jQuery总结/" data-id="cjqghu7770016tsctxdmt1co5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-jq要注意的点" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/08/原-jq要注意的点/" class="article-date">
  <time datetime="2018-12-08T08:09:21.000Z" itemprop="datePublished">2018-12-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/08/原-jq要注意的点/">[原]jq要注意的点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="查找下标"><a href="#查找下标" class="headerlink" title="查找下标"></a><a id="_0"></a>查找下标</h2><p>JQ对象查找指定下标的方法为：eq()</p>
<p>get()方法也是查找指定下标的，但返回的是dom元素</p>
<p>eg:今天写一个导航条绑定鼠标进入事件时播放指定音乐，因为JQ中没有封装audio 和 video 的方法，所以play的方法要绑定在DOM元素，这时如果要是使用eq的话就不对了。</p>
<p><s>一个报错</s></p>
<p>但是这时报错了<code>Uncaught (in promise) DOMException: play() failed because the user didn’t interact with the document first.</code></p>
<p>原来在Chrome 4月份更新了版本后，autoplay政策做了更改</p>
<p><strong>解决方法</strong>：打开 chrome://flags/#autoplay-policy</p>
<p>把Default修改为 No user gesture is required</p>
<h2 id="prop方法"><a href="#prop方法" class="headerlink" title="prop方法"></a><a id="prop_13"></a>prop方法</h2><p>prop()方法  是操作元素的属性</p>
<p>attr()方法是操作标签的属性</p>
<p>对于一些特殊的属性 eg: <code>checked, selected ,disabled</code> 这些值为布尔值的属性，无法使用attr方法设置，因为JQ对于未设置的这些特殊属性会返回undefined，所以要用prop方法</p>
<p>用法和attr相同  eg : <code>prop(&#39;checked&#39;,&#39;true&#39;)</code></p>
<h2 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a><a id="_20"></a>动画队列</h2><p>JQ中会把动画放在一个动画队列中。如果调用多个动画，它也会按照顺序挨个执行，不会覆盖，也会把动画保存好，但同时不好的地方也出现了。如果有一个鼠标进入触发动画的函数，用户多次触发并速度很快，那么鼠标离开后 ，它仍然会执行，直到动画队列中的动画执行完。</p>
<p><strong>解决方法</strong>：stop()方法    停止正在执行的动画</p>
<p>在动画方法前调用此方法就可以解决动画队列的问题。</p>
<p><code>stop(clearQueue,jumpToEnd)</code> 参数值都为布尔型</p>
<p>clearQueue : 是否清除动画队列</p>
<p>jumpToEnd : 是否跳转到当前动画的最终效果</p>
<p>不传参默认都为 false。</p>
<h2 id="index-方法"><a href="#index-方法" class="headerlink" title="index()方法"></a><a id="index_30"></a>index()方法</h2><p>JQ中的index()方法会返回当前元素在所有兄弟元素中的索引<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"><span class="comment">//如果给a标签使用index()方法就只会显示0,要对li标签使用此方法</span></span><br></pre></td></tr></table></figure></p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><a id="_39"></a>删除节点</h2><p>remove()和detach()都是删除节点。</p>
<p>区别：remove方法会删除自身元素及其内容，也会删除事件监听和数据。</p>
<p>detach方法只删除元素本身及其内容。</p>
<p>两种方法都会保留 jQuery 对象中的匹配的元素，返回的是被选择的这个元素，所以可以在将来再使用这些匹配的元素。</p>
<p>所以在进行大规模的增删改时我们可以先把一个元素提取出来，在此元素上面进行操作，在重新添加到页面中，就减少了对DOM的操作的修改，从而减少了页面重绘，但是这种时候最好使用detach()方法，因为此方法不会删除自身的事件及数据。</p>
<h2 id="data方法"><a href="#data方法" class="headerlink" title="data方法"></a><a id="data_48"></a>data方法</h2><p>从1.4.3开始我们通过自定义属性给元素绑定数据，也会被自动的添加到jQuery的数据对象中，因此我们也可以通过data方法操作。</p>
<p>获取：.data(属性名)   不传参是获取所有的</p>
<p>设置：data(属性名：属性值)</p>
<p>删除：removeData(属性名)</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a><a id="_55"></a>事件委托</h2><p>我们可以使用on方式来绑定简单的事件</p>
<p>eg：<code>$(&#39;#box&#39;).on(&#39;click&#39;,function(){})</code></p>
<p>但是如果我们的页面中动态添加的元素不会被绑定到此事件，所以我们可以使用事件委托的方式；</p>
<p><strong>语法</strong>：父元素.on(事件类型,事件委托的子元素，传递给处理函数的数据，事件处理函数)</p>
<p><strong>原理</strong>：通过给父元素注册事件委托，但子元素身上其实是没有事件的。利用了事件冒泡，触发父元素事件，把事件分发给了子元素，最终还是由子元素执行的。支持动态创建添加的元素。</p>
<p><strong>传递的数据</strong>：传递给处理函数的数据，事件触发时可以通过event.data来使用</p>
<h2 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a><a id="_64"></a>克隆节点</h2><p><code>clone(true)</code>    深复制，复制自身及其子元素，并复制其事件和数据</p>
<p><code>clone(false)</code>   浅复制，复制自身及其子元素，不复制其事件和数据</p>
<p><code>clone(true，false)</code>   复制自身及其子元素，并复制父元素的事件和数据但不会复制子元素的事件和数据</p>
<p>只要第一个参数为false，则无论第二个参数无论设置成什么，都为false</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="$冲突"></a><a id="_71"></a>$冲突</h2><p>如果我们一个页面引入多个框架，可能会导致<code>$</code>冲突的问题，默认后面会覆盖前面的，那么在jQuery拿到控制权的前提下，jQuery给我们提供了释放<code>$</code>控制权的方法。</p>
<p><code>$.noConflict()</code>  我们可以使用一个变量来接受一下，用来代替<code>$</code></p>
<p>在没有控制权时也可以使用jQuery来代替<code>$</code></p>
<h2 id="制作jQuery插件"><a href="#制作jQuery插件" class="headerlink" title="制作jQuery插件"></a><a id="jQuery_77"></a>制作jQuery插件</h2><p>我们可以通过给<code>$.fn</code>添加方法开扩展jQuery对象</p>
<p><code>$.fn</code>等价于<code>jQuery.prototype`</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/08/原-jq要注意的点/" data-id="cjqghu75u0004tsctwcimp4pe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-关于属性" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/原-关于属性/" class="article-date">
  <time datetime="2018-12-04T13:19:42.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/原-关于属性/">[原]关于属性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="对象的增删改查"><a href="#对象的增删改查" class="headerlink" title="对象的增删改查"></a><a id="_0"></a>对象的增删改查</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字面量的形式实例化 Object 对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    myName: <span class="string">'周正国'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">添加属性</span><br><span class="line">obj1.age = <span class="number">20</span>;</span><br><span class="line">obj1[<span class="string">'gender'</span>] = <span class="string">'男'</span>;</span><br><span class="line"></span><br><span class="line">修改属性的值</span><br><span class="line">obj1.age += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">访问属性</span><br><span class="line">obj1[<span class="string">'myName'</span>]</span><br><span class="line">obj1.myName</span><br><span class="line"></span><br><span class="line">删除属性</span><br><span class="line"><span class="keyword">delete</span> obj1.age;</span><br></pre></td></tr></table></figure>
<h2 id="遍历对象中的属性"><a href="#遍历对象中的属性" class="headerlink" title="遍历对象中的属性"></a><a id="_22"></a>遍历对象中的属性</h2><ol>
<li>for in 遍历</li>
<li>Object.keys(要遍历的对象)<br>构造函数.方法=function(){}  可以不用实例化对象就可以通过<strong>构造函数.方法（）</strong>来调用，如上。</li>
</ol>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a><a id="_28"></a>对象属性</h2><ol>
<li>数据属性      保存的是数据      <strong>属性名：属性值</strong>的方式</li>
<li>访问器属性   通常用于隐藏数据     用get，set 方法来获取或者设置属性</li>
</ol>
<h2 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a><a id="_33"></a>对象的方法</h2><p>  <strong>判断一个属性是否在对象中</strong></p>
<ol>
<li>in 操作符                   属性名 in 对象名   hasOwnProperty()</li>
<li><p>对象名.hasOwnProperty（属性名）</p>
<p>区别：2只会在对象的自有属性列表中查找，而1不仅会在自有属性列表下查找，还会沿着原型链查找。</p>
<p><strong>判断某个属性是否可枚举</strong></p>
</li>
</ol>
<p><code>对象.propertyIsEnumerable()</code></p>
<p>  <strong>判断一个对象是否是另一个对象的原型</strong></p>
<p><code>原型.isPropertyOf(对象)</code></p>
<h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a><a id="_51"></a>属性的特性</h2><p>  <em><strong>获取属性的特性</strong></em></p>
<p>我们可以通过以下方式获取一个或多个属性的特性</p>
<ol>
<li>Object.getOwnPropertyDescriptor(对象名,要获取的属性名)          获取对象中该属性的特性</li>
<li><p>Object.getOwnPropertyDescriptors（对象名）   获取对象中所有的属性的特性</p>
<p>如下图代码打印一下它们获取到的特性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student=&#123;</span><br><span class="line">       studentName:<span class="string">"大雨"</span>,</span><br><span class="line">       age:<span class="number">20</span>,</span><br><span class="line">       play:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"打豆豆"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">var</span> stu1=<span class="built_in">Object</span>.getOwnPropertyDescriptor(student,<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu2=<span class="built_in">Object</span>.getOwnPropertyDescriptors(student);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(stu1);</span><br><span class="line">   <span class="built_in">console</span>.log(stu2);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/images/jietu01.png" alt="截图"></p>
<p>可以看到得到的是一个对象，那么可以看到它的特性有四个</p>
<ul>
<li>configurable       是否可配置</li>
<li>enumerable        是否可枚举</li>
<li>value                  属性值</li>
<li><p>writable              是否可写<br>当然它们默认都是 true 。我们也可以去控制这些特性。</p>
<p><em><strong>控制属性的特性</strong></em></p>
</li>
</ul>
<ol>
<li>Object.defineProperty(对象名，属性，{修改特性的值 })    —–&gt; 控制一个属性的值</li>
<li>Object.defineProperties(对象名，{属性名：{修改特性的值},属性名：{修改特性的值}})   —–&gt; 控制一个属性的值<pre><code class="javascript"><span class="built_in">Object</span>.defineProperty(student,<span class="string">"age"</span>,{
        value:<span class="number">18</span>,
        configurable:<span class="literal">false</span>,
        enumerable:<span class="literal">false</span>,
        writable:<span class="literal">false</span>
    })
        <span class="built_in">Object</span>.defineProperties(student,{
            gender:{
            value:<span class="string">"女"</span>,
            configurable:<span class="literal">true</span>,
            enumerable:<span class="literal">false</span>,
            writable:<span class="literal">false</span>
            },
            num:{
            value:<span class="number">01</span>,
            configurable:<span class="literal">false</span>,
            enumerable:<span class="literal">false</span>,
            writable:<span class="literal">true</span>
            }
        })
        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(student,<span class="string">"age"</span>))
        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(student)
</code></pre>
</li>
</ol>
<p><img src="/images/jietu02.png" alt="在这里插入图片描述"></p>
<p>所以我们也可以利用这种方式添加属性或者修改属性值，同时设置属性的特性</p>
<h2 id="禁止对象扩展"><a href="#禁止对象扩展" class="headerlink" title="禁止对象扩展"></a><a id="_118"></a>禁止对象扩展</h2><p>查询对象是否可被扩展     Object.isExtensible(要查询的对象名)       默认都为true。</p>
<p>禁止对象扩展     Object.preventExtensions(要禁止的对象名)</p>
<p>禁止对象扩展的特性：不可向对象中添加新的属性</p>
<h2 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a><a id="_123"></a>对象封印</h2><p>判断对象是否被封印     Object.isSealed(要查询的对象名)</p>
<p>封印对象       Object.seal(要封印的对象名)</p>
<p>对象被封印后的特性：不可删除属性，不可添加新属性，可以修改属性值。</p>
<p>所有被封印对象的属性的特性都被设置了：configurable: false</p>
<h2 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a><a id="_128"></a>冻结对象</h2><p>判断对象是否被冻结      Object.isFrozen(要查询的对象名)</p>
<p>封印对象       Object.freeze(要封印的对象名)</p>
<p>对象被封印后的特性：不可删除属性，不可添加新属性，不可修改属性值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/04/原-关于属性/" data-id="cjqghu75v0005tsctqjzicl47" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-继承" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/01/原-继承/" class="article-date">
  <time datetime="2018-12-01T09:08:10.000Z" itemprop="datePublished">2018-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/01/原-继承/">[原]继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_0"></a>定义</h2><p>面向对象的特性：封装，继承，多态。</p>
<p>继承是类与类之间的关系，在面向对象的语言中是为了多态服务的。而js不是一门面向对象的语言，没有类的概念，但是我们可以模拟面向对象，模拟继承。继承是一种父类级别与子类级别的关系。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><a id="_4"></a>方法</h2><p>1、原型继承—-&gt;改变原型的指向</p>
<p><em>原型的作用是数据共享，目的是为了节省内存空间，那么在这我们可以知道原型的另一个作用：继承。所以，继承的作用也是为了节省内存空间。</em></p>
<p>缺陷：因为在改变原型指向的同时初始化了属性，那么继承的属性值都是相同的，只能调用对象的属性重新赋值，这样就</p>
<p>太过于浪费时间了。</p>
<p>2、借用构造函数继承 —&gt; call()方法</p>
<p>缺陷：不会继承原型中添加的方法</p>
<p>3、组合继承 —&gt; 原型继承+借用构造函数继承            改变指向时不初始化属性，既解决了属性问题又解决了方法问题。</p>
<p>4、拷贝继承 —&gt; 把需要共享的属性及方法，通过for in遍历的方式复制到另一个属性中</p>
<p><strong>补充</strong></p>
<p>5、对象继承 —&gt; 可以使用这种方法创建对象，同时指定新对象的原型指向，并且可以设置属性的特性，较为灵活。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.creat(要指向的原型，&#123;</span><br><span class="line">         属性值：&#123;</span><br><span class="line">         value：值，</span><br><span class="line">         enumerable:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">         configurable:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">         writable:<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/01/原-继承/" data-id="cjqghu760000atsctf15bh8je" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-原型和原型链" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/01/原-原型和原型链/" class="article-date">
  <time datetime="2018-12-01T01:02:01.000Z" itemprop="datePublished">2018-12-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/01/原-原型和原型链/">[原]原型和原型链</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_0"></a>定义</h2><p>实例对象中有<strong>proto</strong>这个属性，叫原型，也就是一个对象。这个属性是给浏览器使用的，不是标准的属性。</p>
<p>构造函数有prototype这个属性，也是原型。这个属性是给程序员使用的，是标准的属性。—&gt;它们都可以叫原型对象。</p>
<h2 id="获取对象的原型的值"><a href="#获取对象的原型的值" class="headerlink" title="获取对象的原型的值"></a><a id="_5"></a>获取对象的原型的值</h2><ol>
<li>实例对象.<strong>proto</strong></li>
<li>构造函数.prototype</li>
<li>Object.getPrototypeof(对象名)</li>
</ol>
<h2 id="实例化对象，构造函数和原型对象三者的关系"><a href="#实例化对象，构造函数和原型对象三者的关系" class="headerlink" title="实例化对象，构造函数和原型对象三者的关系"></a><a id="_11"></a>实例化对象，构造函数和原型对象三者的关系</h2><p>1、构造函数可以实例化对象。实例对象是通过构造函数创建的，创建的过程叫实例化，如果传参，就是对属性进行初始化。</p>
<p>2、构造函数中有一个prototype这个属性，是构造函数的原型对象。</p>
<p>3、原型对象中有一个构造器（constructor），构造器指向的是它所在的原型对象所在的构造函数。</p>
<p>4、实例对象的原型对象指向的是它所在的构造函数的原型对象。实例化对象.<strong>proto</strong>==构造函数prototype —-&gt;true。</p>
<p>5、构造函数的原型对象中的方法可以直接被实例对象直接访问。</p>
<p>6、原型对象中的方法可以互相调用。</p>
<p>7、实例对象所使用的方法或属性，首先在实例中查找，找到了直接使用，如果找不到则去实例对象的原型对（<strong>proto</strong>）所指向的原型对象（prototype）中找，找到了使用，找不多就报错。</p>
<h2 id="原型的指向是可以改变的"><a href="#原型的指向是可以改变的" class="headerlink" title="原型的指向是可以改变的"></a><a id="_21"></a>原型的指向是可以改变的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Animal的吃"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Person的玩"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> sheep=<span class="keyword">new</span> Animal();</span><br><span class="line">sheep.eat（）</span><br></pre></td></tr></table></figure>
<p>此时代码会报错，因为把Animal的原型指向了Person的原型，那么sheep将不能调用Animal原型里面的方法。</p>
<p>因为实例对象的原型（<em>proto</em>）指向的是该对象所在的构造函数的原型对象（prototype），构造函数的原型对象（prototype）如果改变了，实例对象（<em>proto</em>）的指向也会改变。</p>
<p>同时<em>Animal也继承了Person</em>。</p>
<p>那么如果又想改变指向，又想访问到方法，<strong>解决方法：在原型改变后再添加方法</strong></p>
<h2 id="原型的简单写法"><a href="#原型的简单写法" class="headerlink" title="原型的简单写法"></a><a id="_44"></a>原型的简单写法</h2><p>构造函数.prototype={</p>
<p>//需要手动修改构造器的指向</p>
<p>constructor:构造函数；</p>
<p>属性：属性值；</p>
<p>方法：function（）{</p>
<p>}</p>
<p>}</p>
<p><strong>这样的写法也是改变了原型指向，让原型指向了一个对象，所以，如果先在原型上添加了一个方法，在使用此方式添加属性和方法，那么在原型上添加的方法将不会被访问到。解决方法：同上</strong></p>
<h2 id="原型链定义"><a href="#原型链定义" class="headerlink" title="原型链定义"></a><a id="_56"></a>原型链定义</h2><p>原型链是实例对象和原型对象通过原型（<strong>proto</strong>）来联系的一种关系。是通过原型继承，形成了一个链条。</p>
<h2 id="原型链的最终指向"><a href="#原型链的最终指向" class="headerlink" title="原型链的最终指向"></a><a id="_59"></a>原型链的最终指向</h2><p>实例对象.<strong>proto</strong>—&gt;构造函数.prototype</p>
<p>实例对象.<strong>proto</strong>.<strong>proto</strong>—&gt;构造函数.prototype.<strong>proto</strong></p>
<p>构造函数.prototype.<strong>proto</strong>—&gt;object.prototype</p>
<p>object.prototype.<strong>proto</strong>—&gt;null</p>
<p>所以object.prototype是顶层</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/01/原-原型和原型链/" data-id="cjqghu75x0006tsctj7u5iyvi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-flex-box布局" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/26/原-flex-box布局/" class="article-date">
  <time datetime="2018-11-26T12:31:14.000Z" itemprop="datePublished">2018-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/原-flex-box布局/">[原]flex box布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>给父级元素设置display：flex会使之转成弹性盒模型，为我们提供了简单方便的设置盒子水平垂直居中的方法。</p>
<ol>
<li><p>设置主轴（水平）方向居中</p>
<p>justify-content :        flex-start  （默认值）主轴起始点位置对齐（水平方向左对齐）</p>
<p>flex-end      主轴的结束位置（水平方向右对齐）</p>
<p>center          居中对齐</p>
<p>space-between    两端对齐，项目之间的间隙相等</p>
<p>space-around    项目之间的间隙比项目到边框的间隙大一倍，与 space-between   的区别在于此方式两端会有一定的空隙，而 space-between 项目是紧挨着边框的</p>
<p><img src="/images/justify-content.png" alt="justify-content 对齐图解"></p>
</li>
<li><p>设置交叉轴（垂直）上的对齐方式</p>
<p>align-items：    stretch （默认值）  当子元素盒子没有设置高度或设置为auto时，垂直方向自适应，也就是高度会填充满父元素</p>
<p>flex-start      交叉轴起始点位置对齐</p>
<p>flex-end       交叉轴的终点对齐</p>
<p>center          交叉轴的中点对齐</p>
<p>baseline       基于第一行文字的基线对齐</p>
<p><img src="/images/align-items.png" alt="align-items对齐图解"></p>
</li>
<li><p>多行沿交叉轴对齐（多行轴线的对齐方式）<strong>如果只有一根轴线，不起作用</strong></p>
<p>align-content :        flex-start      与交叉轴的起点对齐</p>
<p>flex-end       交叉轴的终点对齐</p>
<p>center          交叉轴的中间对齐</p>
<p>space-between    交叉轴两端对齐，均匀分布</p>
<p>space-around        多行中行与行之间的上下距离是最上或最下一行距离上下边框距离的一倍，也就是相当于上图倒过来的效果</p>
</li>
</ol>
<p>那么如果想设置一个盒子垂直水平居中的话就可以给他的父级元素设置： display：flex</p>
<p>justify-context : center</p>
<p>align-item : center</p>
<p>关于子容器的操作方式目前只接触了  设置子容器空间的分配方法flex，收藏了关于这些的一些文章</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/26/原-flex-box布局/" data-id="cjqghu75h0000tsct5nm38z00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/css3/">css3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-原-自定义构造器函数" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/26/原-自定义构造器函数/" class="article-date">
  <time datetime="2018-11-26T03:30:00.000Z" itemprop="datePublished">2018-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/26/原-自定义构造器函数/">[原]自定义构造器函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="总结笔记"><a href="#总结笔记" class="headerlink" title="总结笔记"></a><a id="_0"></a>总结笔记</h2><p>自定义构造器函数相当于一个模板，需要的时候去引用它，函数内没有new和返回值，this是当前对象。</p>
<p>通过new的方式开创建对象，也就是实例化对象，同时对属性进行初始化</p>
<p><em>实例化对象的构造器（constructor）是指向构造函数的。所以，实例对象是通过构造器函数来创建设的，这个创建的过程教实例化</em>。</p>
<p>判断这个对象是否属于这种数据类型的方式有两种：</p>
<p>1、通过构造器方式————&gt;实例对象.constructor==构造函数</p>
<p>2、<strong>instanceof 方式</strong>（尽可能使用这种方式）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    consolo.log(<span class="string">"吃"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="string">"li"</span> ,<span class="number">18</span>)</span><br><span class="line">per.eat()</span><br></pre></td></tr></table></figure></p>
<p>上面的eat（）是一个方法，如果多次创建对象，那么创建的对象中的eat方法不是同一个，所以就会占用大量内存空间，</p>
<p>所以要使用原型。</p>
<p>那么原型的作用之一就是  —&gt;  <strong>数据共享，节省内存空间</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/26/原-自定义构造器函数/" data-id="cjqghu763000btsctney32pd7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-转-全局捕获" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/15/转-全局捕获/" class="article-date">
  <time datetime="2018-11-15T01:15:18.000Z" itemprop="datePublished">2018-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端笔记/">前端笔记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/15/转-全局捕获/">[转]全局捕获</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>全局捕获只支持鼠标事件，不支持键盘事件。</p>
<p>全局捕获： 全局（包含浏览器外）出现一个鼠标事件，会被设置全局捕获的对象捕获，如果此对象正好有对应的事件函数，</p>
<p>那么会被触发，而最初的发起事件的元素就不会执行它的事件函数了，通俗点说就是事件被掠走了。</p>
<p>全局捕获只能执行一次捕获的事件，如果持续捕获可能会出现问题，可以想象下：</p>
<p>如果全局捕获点击事件，鼠标无论点击哪里都会执行那段代码，那么连最基本的关闭浏览器窗口都不行了。</p>
<p>如果持续捕获，必须有取消全局捕获。</p>
<hr>
<p>作者：jerny2017</p>
<p>来源：CSDN</p>
<p>原文：<a href="https://blog.csdn.net/jerny2017/article/details/80282502" target="_blank" rel="noopener">https://blog.csdn.net/jerny2017/article/details/80282502</a></p>
<p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理。这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰</p>
<p>另外，还有一个很重 要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。</p>
<p>所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事 件已经不再发给这个圆点对象了。</p>
<p>web开发和windows开发最大的区别就是windows开发是有状态的，而web开发是无状态的，在windows中，一切操作都可以由程序来控制 ，除非强制执行ctrl+alt+del；但web操作就不一样了，即使执行很重要的操作，用户一点击浏览器关闭按钮，就将前面操作成果化为乌有.尽管可以在onunload事件中加些代码，让用户可以选择是否退出，但不能从根本上解决问题!</p>
<p>前几天，从网上看到setCapture方法，了解了一下，大体是这样的意思，当在IE文档某个区域中使用了这个方法，并且写了onclick或者 onmouse***等有关的鼠标事件方法，那么它就会监视相应的鼠标操作，即使你的鼠标移出了IE，它也一样能捕获到.如果你在某div中的 onclick事件中写了一个alert命令，这时，你点击的关闭按钮，它也一样会弹出alert窗口.releaseCapture与 setCapture方法相反，释放鼠标监控.</p>
<p>利用这个特性，我们可以延缓IE的关闭窗口等破坏性操作，将一些重要的操作能够在破坏性操作执行之前得到处理.</p>
<p>有一点遗憾:setCapture和releaseCapture 不支持键盘事件.只对onmousedown， onmouseup， onmousemove， onclick， ondblclick， onmouseover， onmouseout这样的鼠标事件起作用.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/15/转-全局捕获/" data-id="cjqghu76c000ltsctxr6nxjrr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/前端笔记/">前端笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Es6/">Es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css3/">css3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Es6/" style="font-size: 10px;">Es6</a> <a href="/tags/css3/" style="font-size: 10px;">css3</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/js/" style="font-size: 20px;">js</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/02/原-Es6/">[原]Es6</a>
          </li>
        
          <li>
            <a href="/2019/01/02/转-Evevt-Loop-事件循环/">[转]Evevt Loop 事件循环</a>
          </li>
        
          <li>
            <a href="/2018/12/21/原-jQuery总结/">[原]jQuery总结</a>
          </li>
        
          <li>
            <a href="/2018/12/08/原-jq要注意的点/">[原]jq要注意的点</a>
          </li>
        
          <li>
            <a href="/2018/12/04/原-关于属性/">[原]关于属性</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 yan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>