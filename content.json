{"meta":{"title":"Hey 这里是闫大雨","subtitle":null,"description":"个人博客","author":"yan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"[原]jwt","slug":"原-jwt","date":"2019-03-02T13:23:51.000Z","updated":"2019-03-06T13:54:47.364Z","comments":true,"path":"2019/03/02/原-jwt/","link":"","permalink":"http://yoursite.com/2019/03/02/原-jwt/","excerpt":"","text":"jwtjwt是jsonwebtoken的简称，用来生成token。在登陆状态验证完成时发送给前台一个token，之后前台的请求都要带着token，后台验证其token的正确性及有效性之后才会回应其数据，在用户和服务器端之间安全的传递消息。jwt实际是一个字符串，由三部分组成，头部，数据和签名。 生成token1const jwt = require('jsonwebtoken') 我们在页面引入jsonwebtoken后，可以使用其方法sign来生成token.jwt.sign(payload,secret,[options,callback])sign方法有四个参数，第一个是生成的token中包含的一些数据，此参数可以是一个对象，字符串或buffer。如果是对象，会使用JSON.stringify()转为json格式。可以在对象中写一个ID,user-agent等信息;第二个参数是一个密钥，记录在服务器中，在验证时需要用到此参数;第三个是一些选项，经常用的大概就是有效期(expiresIn)，有效期的值以秒计数，也可以使用一些带有时间跨度的字符串，eg：’7d’,’5h’等;第四个是一个回调，回调的第一个参数是err,第二个是token。但此方法会默认返回token; 下面是贴了实例的代码，在其中还使用了level存储了一个状态和时间12345678910111213141516171819202122232425262728293031323334353637383940414243444546const jwt = require('jsonwebtoken');const level = require('level');// 创建实例var db = level('./mydb')// 密钥var serect = 'yandayu'// 获取GUIDfunction generateGULD() &#123; return new Date().getTime()&#125;// 生成tokenfunction generateToken(req, GUID, opts) &#123; opts = opts || &#123;&#125; // 默认有效期为7天 var expiresDefault = '7d'; var token = jwt.sign(&#123; auth: GUID, agent: req.headers['user-agent'] &#125;, serect, &#123; expiresIn: opts.expires || expiresDefault &#125;) return token;&#125;function generateAndStoreToken(req, opts) &#123; var GUID = generateGULD(); var token = generateToken(req, GUID, opts) var record = &#123; valid: true, created: new Date().getTime() &#125; // 把数据插入存储区 db.put(GUID, JSON.stringify(record), function (err) &#123; console.log(err) &#125;) return token;&#125;exports = module.exports = &#123; generateAndStoreToken&#125;;","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"jwt","slug":"jwt","permalink":"http://yoursite.com/tags/jwt/"}]},{"title":"[原]typescript","slug":"原-typescript","date":"2019-01-24T13:23:51.000Z","updated":"2019-01-24T13:57:07.880Z","comments":true,"path":"2019/01/24/原-typescript/","link":"","permalink":"http://yoursite.com/2019/01/24/原-typescript/","excerpt":"","text":"##变量声明##12345// 变量声明,约束形参tel的类型function phone(tel:number) &#123; console.log(tel) &#125;phone(1234) ##接口## 1234567891011121314151617// 定义接口。用来定义一些规则，使用此规则就要严格遵守interface obj &#123; //obj相当于这些规则的名字 readonly name:string; // 表示此属性是只读的 age?:number; // 在属性后加？表示不是必需的，可不传&#125;// stu函数的参数student用了这个规则，所以student中的属性必须要有一个名为name并且值的类型为字符串。属性的顺序不加规定function stu(student: obj)&#123; let newStudent = &#123; name:'lisa', age:22, gender:'女' &#125; if (student.name) newStudent.name=student.name; return newStudent;&#125;let newStu = stu(&#123;name:'pula'&#125;)console.log(newStu) ##数组## 1234567891011121314151617181920let arr1: string[]=['1','2'] // 定义一个字符串类型的数组。数组类型写在[]前let arr2: ReadonlyArray&lt;string&gt; = ['3','4'] //定义一个只读的字符串型的数组// 就算是把arr1赋给arr2也不行，只能重改类型arr1 = arr2 as string[];// 下面这种方式也是不行的，因为arr2不允许改变// arr2 = arr2 as string[];// 如果我们定义了一个规则,这里的color属性是可选的interface colors&#123; color?: string; [property: string]: any; &#125;function create(crec:colors) &#123; console.log(crec)&#125; create(&#123; colour: 'red' &#125;) // 在这里我们传了一个属性为colour的属性，但它仍然会报错，// 因为对象字面量会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在规则中不包含的属性时就会报错// 解决方法：在接口中定义 [property:string]: any ; 表示crec可以有任意数量的其他属性。// 官方文档说另一种解决方法是把对象使用变量保存一下再传入函数中，但是试了试还是报错，原因未知，所以先使用上一个方法。 ##索引签名## 12345678910111213141516// 声明索引类型及返回的类型,索引签名只能是string或number。当索引签名为数字时，系统会自动转为字符串来索引// 所以数字索引的返回值必须是字符串索引返回类型的子类型(通过extends来创建的派生类)interface NumberDictionary &#123; [index: number]: string; // [index: string]: number; 这样时错误的&#125;interface StringDictionary &#123; readonly [index:string]:number //这样就不能通过索引来改变值&#125;var arr3: NumberDictionary;arr3 = [\"aa\", \"bb\", \"cc\"]; // 同时数组中的值只能为字符串var arr4: StringDictionaryarr4 = &#123; 1: 44, 2: 55 &#125;;console.log(arr3[1]);console.log(arr4[1]); //所以这里即使定义的是字符串却依然可以使用数字来索引,得到的值是一样的 ##类## 123456789101112class Person &#123; public name: string; // public修饰符，成员可以在任何地方访问，默认问public private age: number; // 添加了private只允许在这个类中访问 constructor(tname:string,tage:number)&#123; this.name = tname; this.age = tage; &#125; greeting()&#123; console.log(`Hi,I am $&#123;this.name&#125; and I am $&#123;this.age&#125; years old`) &#125;&#125;// protected也允许在派生类访问，还有我们之前用的readonly修饰符，表明是只读属性，必须在声明或构造函数里被初始化类似于const ##继承## 1234567891011121314// 继承class Student extends Person &#123; constructor (name,age)&#123; super(name,age) // 在构造函数里访问this属性之前必须使用super方法 &#125; greeting ()&#123; console.log('子类重写的方法') // 子类重写了greeting方法 super.greeting() // 必须调用super才能调用基类的greeting函数 &#125;&#125;var per = new Person('lisa',22);var stud = new Student('pupu',25);per.greeting() //打印： Hi,I am lisa and I am 22 years oldstud.greeting() //第一次打印：子类重写的方法；第二次： Hi,I am pupu and I am 25 years old","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"ts","slug":"ts","permalink":"http://yoursite.com/tags/ts/"}]},{"title":"[原]Vuex","slug":"原-Vuex","date":"2019-01-23T14:23:51.000Z","updated":"2019-01-23T14:16:39.867Z","comments":true,"path":"2019/01/23/原-Vuex/","link":"","permalink":"http://yoursite.com/2019/01/23/原-Vuex/","excerpt":"","text":"##Vuex## 在使用@vue/cli脚手架搭建时，选择vuex后会生成store.js文件，并且已经做了引入Vue，Vuex,实例Vuex等基本的操作。12345678910111213141516171819202122232425262728 // 实例有五个选项export default new Vuex.Store(&#123; state: &#123; // 用来托管数据 notes: ['one', 'two'] &#125;, mutations: &#123; // 用来直接更改state中数据的状态，同步 // 可以定义多种方法，每个方法中会传入两个值，第一个为state，第二个为传入的数据 ADD_NOTE (state, payload) &#123; state.notes.push(payload) &#125; &#125;, actions: &#123; // 用来像mutations提交，但不直接更改数据，可以保护异步操作 // context是一个与store实例具有相同方法和属性的对象,payload为传入的数据 addNote (context, payload) &#123; // 向mutations中ADD_NOTE提交数据 context.commit('ADD_NOTE', payload) &#125; &#125;, getters: &#123; // 与访问器属性的get方法类似，用来提供数据 notes: state =&gt; state.notes &#125;, module: &#123; // 可以把store分割多个模块，每个模块中都有自己的state，mutations，actions，getters，module&#125;) ##通过dispatch触发action中的方法##12// 当实例后根组件及其子组件中都会被注入$store属性，通过此属性来访问实例中的内容this.$store.dispatch('addNote', this.message) ##辅助函数##12345678910111213// 在分模块时store的方法较多，可以使用此辅助函数把各个模块的getters和actions的方法展开在组件中，不用再通过this.$store.getters/dispatch()的方法来调用 import &#123;mapGetters, mapActions&#125; from 'vuex' // 引入方法 computed:&#123; ...mapGetters(['cartItems']) &#125;, created()&#123; // 直接调用 this.getCartItems() &#125;, methods:&#123; // 把vuex的store中获取商品和清空的方法，展开在此组件自有方法中，可以直接调用 ...mapActions(['getCartItems','deleteAll']) &#125;,","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"[原]Vue-store","slug":"原-Vue-store","date":"2019-01-22T12:23:51.000Z","updated":"2019-01-22T12:15:10.954Z","comments":true,"path":"2019/01/22/原-Vue-store/","link":"","permalink":"http://yoursite.com/2019/01/22/原-Vue-store/","excerpt":"","text":"##使用store模式## 用store模式写一个周记，图示如下： 实现编辑删除，添加等功能，点击某天，下面添加处Day of event:显示的为对应星期。 使用store就是把数据(这里是假数据)托管到store的js文件上，各个组件中修改，删除等操作，不直接对数据进行操作。而是通知store去操作，所有方法写在store 文件中，在操作时调用即可。在项目简单时使用store模式即可，在项目较为复杂时可以使用vuex。 下面为store文件的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import &#123;seedData&#125; from './seed.js'//状态管理，页面中有任何改变或查询时，都通知store进行改变，而不在页面进行改变export const store = &#123; // 托管数据 state:&#123; seedData &#125;, // 获取激活状态的天数 getActiveDay()&#123; return this.state.seedData.find(day =&gt; day.active) &#125;, // 点击哪天，把哪天设置为激活状态 setActiveDay(dayID)&#123; this.state.seedData.map(function(day)&#123; day.id == dayID ? day.active = true :day.active = false &#125;); &#125;, // 为激活状态天数添加事件 addEvent(message)&#123; if(message) &#123; this.getActiveDay().events.push(&#123; details: message, edit: false &#125;) &#125; &#125;, // 封装获取指定天数，指定事件，及事件索引 getEventDetails(dayId, details)&#123; const dayObj = this.state.seedData.find(day =&gt; day.id == dayId ); var resObj = &#123; dayObj &#125; dayObj.events.forEach(function(event,index)&#123; if(event.details == details) &#123; resObj.event = event resObj.index = index &#125; &#125;) return resObj; &#125;, // 点击编辑，将事件处于编辑状态 editEvent(dayId, eventDetails)&#123; // 将其他编辑状态都变为false this.state.seedData.map(function (obj) &#123; obj.events.map(event =&gt; event.edit = false) &#125;) this.getEventDetails(dayId, eventDetails).event.edit = true; &#125;, // 删除指定事件 deleteEvent(dayID, eventDetails)&#123; let delObj = this.getEventDetails(dayID, eventDetails) if (delObj.index &gt;= 0)&#123; delObj.dayObj.events.splice(delObj.index,1) &#125; &#125;, // 修改指定事件 changeEvent(dayId, oldEventDetails, newDetails)&#123; // 如果新数据为空，则不修改，把旧数据赋值给新数据 if (newDetails == '') newDetails = oldEventDetails const changeEvents = this.getEventDetails(dayId, oldEventDetails).event changeEvents.details = newDetails changeEvents.edit = false &#125;&#125;","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"[原]Vue-组件","slug":"原-Vue-组件","date":"2019-01-17T11:23:51.000Z","updated":"2019-01-16T13:33:46.354Z","comments":true,"path":"2019/01/17/原-Vue-组件/","link":"","permalink":"http://yoursite.com/2019/01/17/原-Vue-组件/","excerpt":"","text":"注册组件12345678910111213141516171819202122232425262728293031 //要先注册再实例，此为全局组件Vue.component('button-counter',&#123; //data必须是一个函数 data:function()&#123; return &#123; count:0 &#125; &#125;, template:'&lt;button type=\"button\" @click=\"count++\"&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;'&#125;); //局部组件new Vue(&#123; el:'#app', components:&#123; //在根组件下注册一个父组件，只能在#app下使用 'parent-button':&#123; //在父组件下定义一个子组件，只能在父组件下使用 components:&#123; 'child-button':&#123; data:function()&#123; return &#123;count:0&#125; &#125;, template:'&lt;button type=\"button\" @click=\"count++\"&gt;点击了&#123;&#123;count&#125;&#125;次&lt;/button&gt;' &#125; &#125;, //注册子组件 template:'&lt;child-button&gt;&lt;/child-button&gt;' &#125; &#125;&#125;); 组件之间传递数据（父 –&gt; 子）1234567891011121314151617181920212223242526272829&lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;info&#125;&#125;&lt;/h1&gt; &lt;!-- 从根组件往子组件传递动态数据message --&gt; &lt;child-component :message=\"info\"&gt;&lt;/child-component&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; //组件的作用域：每个组件都是独立的，不能相互访问。 //从父级组件往子级组件中传递数据时，在子组件上面写一个属性，属性值为要传递的数据。如果传递的是动态数据，要绑定此属性，也就是说在属性前加v-bind:简写为： new Vue(&#123; el:'#app', data:&#123; info:'根组件数据' &#125;, components:&#123; 'child-component':&#123; //用props接数据,还可以进行校验 props:&#123; 'message':&#123; type:String,//(默认为any,也可以自己定义类型，多个类型用数组) required:true,//为true 时必须传值，否则可不传 default:'' //默认值 &#125; &#125;, template:'&lt;div&gt;&lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/div&gt;' &#125; &#125; &#125;);&lt;/script&gt; 自定义事件(子 –&gt; 父)12345678910111213141516171819202122232425262728293031323334&lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;info&#125;&#125;&lt;/h1&gt; &lt;!-- 自定义事件 --&gt; &lt;child-component @pass-mess=\"changeMessage\"&gt;&lt;/child-component&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data: &#123; info: '根组件数据' &#125;, components: &#123; 'child-component': &#123; data:function()&#123; return &#123;childMessage:'子组件的数据'&#125; &#125;, template: '&lt;div&gt;&lt;h1&gt;&#123;&#123;childMessage&#125;&#125;&lt;/h1&gt;&lt;/div&gt;', //初始化后获取子组件的数据 created: function () &#123; //触发自定义事件，并传入子组件的数据 this.$emit('pass-mess', this.childMessage) &#125; &#125; &#125;, methods: &#123; // 自定义事件触发的函数 changeMessage:function(message)&#123; this.info = message &#125; &#125; &#125;);&lt;/script&gt; 我们也可以直接通过实例属性来访问.$children 子组件，是一个数组，可以通过索引拿.$parent 父组件，只有一个.$root 根组件子组件的索引 我们如果复用了多次子组件，通过实例属性索引来拿不确保能拿到相应顺序的子组件。所以我们可以为每个组件添加一个特有的索引，使用 ref=”索引名”。通过.$refs.索引名来准确拿到我们想拿的组件。 使用插槽分发内容1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id=\"app\"&gt; &lt;child&gt; &lt;!-- 标签会插到指定名字的插槽中 --&gt; &lt;span slot=\"slot1\"&gt;&#123;&#123;rootMessage&#125;&#125;&lt;/span&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;!-- 使用对象解构的形式接收一个对象 ,也相当于从子组件往父组件传递了数据--&gt; &lt;template slot-scope=\"&#123;stu&#125;\" slot=\"slot2\"&gt; &lt;h1&gt;&#123;&#123;stu.name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;&#123;&#123;stu.age&#125;&#125;&lt;/h1&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt;&lt;script type=\"text/javascript\" src=\"vue.js\"&gt;&lt;/script&gt;&lt;script type=\"x-template\" id=\"childTemplate\"&gt; &lt;!-- 模板中的内容会覆盖child标签及内容,如果不想覆盖就要使用插槽solt --&gt; &lt;div&gt; &lt;slot name=\"slot1\"&gt;&lt;/slot&gt; &lt;!-- 没有name的为默认插槽，所有没有slot属性的标签都会被加到这个插槽中 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 从子组件传递一个对象 --&gt; &lt;slot :stu=\"student\" name=\"slot2\"&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data:&#123; rootMessage:'根组件', count:1 &#125;, components: &#123; 'child': &#123; data:function()&#123; return &#123; student: &#123; name: 'lisa', age: 20 &#125;&#125; &#125;, template: '#childTemplate' &#125; &#125; &#125;); 动态组件12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;a href=\"#\" @click.prevent=\"page='index'\"&gt;首页&lt;/a&gt; &lt;a href=\"#\" @click.prevent=\"page='about'\"&gt;关于我们&lt;/a&gt; &lt;a href=\"#\" @click.prevent=\"page='contract'\"&gt;联系我们&lt;/a&gt; &lt;!-- 动态组件 is的值绑定为哪个组件就显示指定组件的模板，component相当于一个占位符，不会输出 但切换时，动态组件都会重新渲染，所以组件的状态不会被保存，我们可以使用keep-alive使其保持状态 include里面的组件会保持状态，exclude里面的不会--&gt; &lt;keep-alive include=\"index,about\" exclude=\"contract\"&gt; &lt;component :is=\"page\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt;&lt;script type=\"text/javascript\" src=\"vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#app', data:&#123; page:'index' &#125;, components: &#123; 'index':&#123; template:'&lt;div&gt;&lt;h1&gt;首页&lt;/h1&gt;&lt;input type=\"text\"&gt;&lt;/div&gt;' &#125;, 'about': &#123; template: '&lt;div&gt;&lt;h1&gt;关于我们&lt;/h1&gt;&lt;input type=\"text\"&gt;&lt;/div&gt;' &#125;, 'contract': &#123; template: '&lt;div&gt;&lt;h1&gt;联系我们&lt;/h1&gt;&lt;input type=\"text\"&gt;&lt;/div&gt;' &#125; &#125;, &#125;);&lt;/script&gt;","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"[原]Vue-基础语法","slug":"原-Vue-基础语法","date":"2019-01-16T10:23:51.000Z","updated":"2019-01-16T13:33:00.489Z","comments":true,"path":"2019/01/16/原-Vue-基础语法/","link":"","permalink":"http://yoursite.com/2019/01/16/原-Vue-基础语法/","excerpt":"","text":"实例与模板语法 12345678 &lt;div id=\"app\"&gt; &lt;!--插入文本和标签都会覆盖标签中的内容,&#123;&#123;&#125;&#125;不会覆盖 --&gt; &lt;p&gt;&#123;&#123;messages&#125;&#125;&lt;/p&gt; &lt;!-- 元素中使用数据 --&gt; &lt;input type=\"text\" v-model=\"message\"&gt; &lt;!-- 为input绑定value值，当input改变value值时，message的值也会改变（双向绑定） --&gt; &lt;p v-text=\"message\"&gt;&lt;/p&gt; &lt;!-- 插入文本 --&gt; &lt;div v-html=\"tags\"&gt;&lt;/div&gt; &lt;!-- 插入标签 --&gt;&lt;/div&gt; 123456789101112131415161718var app = new Vue(&#123; el:'#app', //挂载点，数据只能在挂载点下的元素使用 data:&#123; message:'hello vue!', tags:\"&lt;span&gt;绑定标签&lt;/span&gt;\" &#125;, //数据 template:'&lt;h1&gt;&#123;&#123;messages&#125;&#125;&lt;/h1&gt;',//模板会与数据结合，之后挂在挂载点上，会替换掉挂载点，所以当有多个元素时，要有一个根元素（父元素）包裹。当模板的代码过多时可以把代码写在&lt;script type=\"x-template\"&gt;标签下，给script加个id值，使用：template：'#id值' methods:&#123; greeting:function()&#123; alert(this.message); &#125; //绑定事件：v-on:click=\"greeting\"/@click=\"message\"。不传值时可以不写括号 &#125;, computed:&#123; messages:function()&#123; return this.message + \"!\" &#125; &#125; //计算属性，与js中的访问器属性类似 &#125;) 生命周期方法 这些方法是在实例各个阶段所触发的 eforeCreate 在实例初始化之后，数据观测事件配置之前被调用 reated 在实例创建完成后被立即调用，未挂载时 eforeMount 在挂载开始之前被调用 ounted 在挂载完成后立即调用 eforeUpdate 数据更新时调用 pdated 数据更新渲染后调用 ctivated keep-alive 组件激活时调用 eactivated keep-alive 组件未激活时调用 eforeDestroy 实例销毁之前调用 estroyed 实例销毁后调用 rrorCaptured 当捕获一个来自子孙组件的错误时被调用 操作类名与样式 12345678910111213141516171819202122232425262728293031&lt;div id=\"app\"&gt; &lt;!-- v-bind:简写为： v-on:简写为@ --&gt; &lt;!-- 操作类名 表达式为真时加类名--&gt; &lt;div :class=\"&#123;'active':info&gt;=10&#125;\"&gt;&lt;/div&gt; &lt;!-- 数组形式 --&gt; &lt;div :class=\"[active?'active':'unactive']\"&gt;&lt;/div&gt; &lt;!-- 操作样式 --&gt; &lt;div ：style=\"&#123;witdth:'300px',height:'200px'&#125;\"&gt;&lt;/div&gt; &lt;div :style=\"style\"&gt;&lt;/div&gt; &lt;!-- 数组的形式 --&gt; &lt;div :style=\"[style,style2]\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue(&#123; el:'#app', data:&#123; info:12, active:true, style:&#123; witdth:'200px', height:'200px', background:'red' &#125;, style2:&#123; witdth:'200px', height:'300px', background:'green' &#125; &#125; &#125;) &lt;/script&gt; 条件渲染 1234567891011121314151617&lt;div id=\"app\"&gt; &lt;!-- 当代码过多时，可以使用template标签，加载时会提取template中的内容到页面 --&gt; &lt;div v-if=\"mess &lt; 10\"&gt; mess&lt;10 &lt;/div&gt; &lt;div v-else-if=\"mess == 10\"&gt; mess == 10执行 &lt;/div&gt; &lt;div v-else&gt; mess&gt;10 &lt;/div&gt; &lt;!-- 两者区别：v-if只会在满足条件时开始渲染，并且在切换时会销毁绑定数据等，条件满足时再重建 而v-show在页面加载就会渲染，只是单纯的改变元素的css属性display的值。 在频繁切换时使用v-show比较好，条件很少改变时使用v-if较好--&gt; &lt;div v-show=\"20&lt;10\"&gt; v-show &lt;/div 列表渲染 1234567891011121314151617181920212223242526 &lt;div id=\"app\"&gt;&lt;!-- v-for可以渲染的有数组，对象，数字。字符串 语法为item in items 为了给Vue一个提示，给每个元素加上一个唯一的key值，防止复用。 不要与v-if一同使用,当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要使用，可以把要遍历的数组/对象等替换为一个计算属性，过滤后在遍历添加元素--&gt; &lt;ul &gt; &lt;li v-for=\"(student,index) in students\"&gt;&#123;&#123;index&#125;&#125;-&#123;&#123;student&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;!-- 当遍历对象时，形参为属性值，属性，索引 --&gt; &lt;div &gt; &lt;h2 v-for=\"(value,key,index) in personInfo\" :key=\"index\"&gt;&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt;var app = new Vue(&#123; data:&#123; students:['Lisa','pola','rose'], personInfo:&#123; name:'一班', age:20, gender:'女', address:'郑州' &#125; &#125;&#125;) &lt;/script&gt; 事件处理绑定事件使用v-on:事件类型 = “”的形式,括号里可以写简单的代码或者函数名，不需要传参时可以不加括号。如果传参的形式，函数内需要用事件对象，要把$event以参数的形式传入。v-on:可以简写为@1234567891011121314&lt;a @click.stop=\"alert('hey')\"&gt;&lt;/a&gt;&lt;!-- .stop 是事件修饰符,用处为停止冒泡。 Vue为我们提供了一下几种事件修饰符: .prevent 阻止默认事件 .capture 捕获阶段执行 .self 事件不是从冒泡或捕获来的，是自身的事件 .once 只触发一次 按键修饰符： .exact 当只有绑定的按键独自按下时触发，组合按下不会触发 .left .right .middle 表单修饰符: .trim 前后去空格 .number 转为数字 .lazy 当内容改变触发焦点触发(change) --&gt; 表单值绑定12345678910&lt;label&gt;婚否:&lt;input type=\"checkbox\" true-value=\"已婚\" false-value=\"未婚\" v-modal=\"marry\"&gt;&lt;/label&gt;&lt;label&gt;男&lt;input type=\"radio\" :value=\"male\" v-modal=\"gender\"&gt;&lt;/label&gt;&lt;script type=\"text/javascript\"&gt; var app = new Vue(&#123; data:&#123; marry:false, male:'男' &#125; &#125;) &lt;/script&gt; 监视数据的变化1234567891011121314151617181920212223242526272829new Vue(&#123; el: '#app', data: &#123; name:'张三', age:20, phone:&#123; brand:'OPPO', number:12354 &#125; &#125;, watch: &#123; name:'changeName',//可以传入一个自定义的处理函数 age:function(newMess,oldMess)&#123; //默认的处理函数，有改变前的数据和之后的数据 &#125;, phone:&#123; handler:function(newMess, oldMess)&#123;&#125;, deep:true, //深度监视，当对象中的属性改变时也会被监视到 immediate:true //打开页面会立即执行一次回调 &#125;, 'phone.brand': function (newMess, oldMess)&#123;&#125; //监视对象中的某个属性，因为有.所以要加引号 &#125;, methods: &#123; changeName:function()&#123; //name改变时的处理函数 &#125; &#125;&#125;);","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"[原]less","slug":"原-less","date":"2019-01-10T12:23:51.000Z","updated":"2019-01-16T13:33:21.989Z","comments":true,"path":"2019/01/10/原-less/","link":"","permalink":"http://yoursite.com/2019/01/10/原-less/","excerpt":"","text":"我们在项目中使用less时，可以分开创建各个类型，创建一个专门保存变量的less 文件，一个混入方法的文件等，有利于以后的维护 声明编码类型防止乱码1@charset \"utf-8\"; 变量12345678910/*必须@前缀,;结尾,:为等于。变量名不能以数字开头，不能包含特殊字符，区分大小写 */@textColor:#333;a&#123; color: @textColor;&#125;/* 也可以用来声明一个类名，但变量与其他字符拼接时，要加&#123;&#125;来表明哪个是变量 */@className:box;.@&#123;className&#125;&#123; color:@textColor;&#125; mixin混入123456789101112131415/* 类混合，这种方式类也会被编译进css中，但是我们不会使用，所以使用函数的形式 */.h50&#123; height: 50%;&#125;.f_r&#123; float: right;&#125;.h50-f_r&#123; .h50; .f_r;&#125;/* 定义函数，函数不会被编译进css中 */.w50()&#123; width: 50%;&#125; 12345678910/* 传参的函数，如果没有默认值，使用时必须要传参;不传参时不写括号 默认值写法与变量写法相同 */.f(@direction:left)&#123; float: @direction;&#125;.w50-f&#123; .w50; .f(right);&#125; 嵌套12345678910111213141516171819202122.header&#123; display: block; img&#123; display: none; &#125; /* 需要连接时使用：&amp; */ &amp;:hover&#123; img&#123; display: block; &#125; &#125;&#125;/* 会解析为以下形式*/ .header&#123; display:block &#125; .header img&#123; display:none &#125; .header:hover img&#123; display:block &#125; 使用@import 导入文件 1234@import \"./main.less\";a&#123; background: @bgc;&#125; 转义：~””,放在此引号中的任何东西都会被转义，原样输出 123456@minw: ~\"(min-width:768px)\";.box&#123; @media @minw&#123; width: 400px; &#125;&#125; 并且指令会冒泡，为以下形式12345@media (min-width:768px) &#123; .box &#123; width: 400px; &#125;&#125; 命名空间123456789101112#group1()&#123; .btn&#123; -webkit-appearance: none; width: 40px; background-color: #ccc; border: 1px solid #fff; &#125;&#125;/* 使用时 */.box button&#123; #group1 &gt;.btn&#125; 循环 mixin可以调用本身，结合Guard和模式匹配，可以创建各种循环/迭代的结构。下面是官网给的例子，when是当条件满足时执行函数12345678.loop(@counter) when (@counter &gt; 0) &#123; .loop((@counter - 1)); // next iteration width: (10px * @counter); // code for each iteration&#125;div &#123; .loop(5); // launch the loop&#125; 在做移动端rem适配时使用了此方法，便于维护，并且用到了几个内置函数 less的变量可以定义数组：@deviceList:750px,640px,340px;拿数组的长度length()：@len:length(@deviceList)拿数组中的数据extract()12@index:1;extract(@deviceList,@index)","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"less","slug":"less","permalink":"http://yoursite.com/tags/less/"}]},{"title":"[原]gulp","slug":"原-使用gulp搭建自动化环境","date":"2019-01-09T13:44:51.000Z","updated":"2019-01-10T08:45:13.518Z","comments":true,"path":"2019/01/09/原-使用gulp搭建自动化环境/","link":"","permalink":"http://yoursite.com/2019/01/09/原-使用gulp搭建自动化环境/","excerpt":"","text":"基于node的工具，要确保安装了node 全局安装gulp 的命令行 $ npm install gulp-cli -g 创建一个项目并切到该文件夹中 $ mkdir 文件名 &amp;&amp; cd 文件名 初始化（会多一个package.json的文件，所有设置及依赖会显示在该文件中），会问你几个关于项目的名称版本等问题，如果使用默 认的，可以再后面加-y，就会直接创建。 $ npm init -y 作为项目依赖安装gulp $ npm install gulp -D 创建一个gulpfile.js的文件，如果文件名不为此名称，需要在package.json中修改main的值为对应的名称。可以在json文件中添加 “private”: true ，让项目成为私人的。 在gulpfile.js文件中引入gulp及所需要的src,dest,pipe,series,watch一系列内置插件 安装压缩混淆js文件的插件（gulp-uglify），压缩html文件的插件（gulp-htmlmin），压缩css文件的插件（gulp-cssnano），服务器的插件（gulp-connect），都引入到文件中 创建压缩混淆js文件的任务 1234567//压缩混淆js 有返回值的不用回调function script()&#123; return src('src/js/*.js') .pipe(uglify()) .pipe(dest('dist/js')) .pipe(connect.reload())&#125; 使用src方法找到要压缩混淆的文件，pipe方法为管道传输，传输过程中使用压缩混淆的方法处理后，（dest方法为输出）处理后输出到dist文件下的js文件下，最后自动刷新压缩html和css方法除了所用的插件不一样外，都相同。 任务创建完成后，使用watch方法监听三个任务，任务中如果没有返回值要添加一个回调 1234567// 监听文件变更function watchFile(cb)&#123; watch('src/**/*.js',script) watch('src/**/*.css',css) watch('src/*.html',html) cb()&#125; 之后创建服务器的任务，监听dist目录的文件，和8080的端口，保持刷新 123456789//实时刷新function serve(cb)&#123; connect.server(&#123; root:'dist', port:8080, livereload:true &#125;) cb()&#125; 最后把监听与服务器的任务导出到默认值中，当执行任务时两个任务都会执行 12//导出exports.default = series(serve,watchFile) 使用node 执行该任务（因为设置了默认值，所以不用写任务名） gulp ，接下来在浏览器中访问localhost：8080，项目所做的变化，保存页面后就会自动刷新，并且自动压缩。 如果觉得npm下载包太慢，可以使用淘宝镜像$ npm install -g cnpm --registry=https://registry.npm.taobao.org执行此命令后，以后的npm操作就要以cnpm代替npm","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"[原]express","slug":"原-experss","date":"2019-01-09T09:23:51.000Z","updated":"2019-01-10T09:27:43.371Z","comments":true,"path":"2019/01/09/原-experss/","link":"","permalink":"http://yoursite.com/2019/01/09/原-experss/","excerpt":"","text":"express是一个基于node.js的web开发框架 首先要安装express插件并引入到js文件中，express是一个函数，所以要调用，调用后会返回一个实例（appplication）， 使用实例的一些方法来完成我们的项目。 express有四种方法，前三种为中间件方法： express.static(root[,option]) 12// 托管静态文件app.use(express.static(&apos;public&apos;)); app为express的实例，因为托管静态文件是中间件方法，所以使用了它的use方法 express.json这个方法是用来解析请求体的内容（解析application/json编码类型的数据），因为请求体中默认为空，当解析时才会被填充 express.urlencoded([options])与上个方法一样，只是用来解析application/x-www-form-urlencoded”编码类型的数据。这两中方法都要在版本v4.16.0 以上才能使用。如果版本低，可以使用body-parser插件来解析 express.Router([options])创建一个路由器对象，当一个js文件中有多种类型的接口时，我们可以把一种类型的拿出来，放在另一个js文件中，引入需要的插件，使用router实例代替app实例调用各种方法，最后导出整个页面。 response方法（只列出了用到的方法，具体官网查询） response.send() 向浏览器发送消息response.end() 结束响应的进程response.status() 设置响应的HTTP状态response.header() 设置响应头 request request.body 请求体 application app.METHOD(path，callback) METHOD可以为get,post,put等，使用指定的回调函数将HTTP请求路由到指定的路径。实际方法：app.get(path，callback)app.listen(port[,callback]) 监听指定端口app.use([path,] callback [, callback...]) 安装指定的中间件在指定路径上执行的一个或多个函数当所请求路径的匹配时执行中间件函数。 router router.METHOD(path, [callback, ...] callback) METHOD可以为get,post,put等，与app方法同理 使用了node 的fs文件系统 fs.readFile(path[,options],callback) 读取文件，回调中有err和data的参数fs.writeFile(path[,options],callback) 写文件，回调中有err的参数 实例 下面是专门写接口的js文件，因为太长，所以只列出了获取和添加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const express = require('express');const router = express.Router();const fs = require('fs');const path = require('path');//json文件所在路径const stuAdd = './../data/students.json';// 获取数据router.get('/', function (req, res) &#123; //读取文件，并返回给浏览器 fs.readFile(path.join(__dirname + stuAdd), 'utf8', function (err, data) &#123; if (err) &#123; return res.send(err) &#125; res.status(200).send(data) &#125;)&#125;)// 创建router.post('/create', function (req, res) &#123; //设置id等数据 let newS = &#123; id: Date.now(), name: req.body.name, age: req.body.age, gender: req.body.gender, clazz: req.body.clazz, address: req.body.address, creat: new Date().toLocaleString(), update: new Date().toLocaleString() &#125;; //读取文件并把新的内容传入json文件 fs.readFile((__dirname + stuAdd), 'utf8', function (err, data) &#123; //如果有错，抛出错误，防止格式错误 if (err) throw err try &#123; data = JSON.parse(data) &#125; catch (error) &#123; return res.status(200).send(error) &#125; data.push(newS) //把新数据传入json文件 fs.writeFile(path.join(__dirname + stuAdd), JSON.stringify(data, null, 4), function (err) &#123; res.status(200).send(data) &#125;) &#125;)&#125;)//导出整个页面exports = module.exports = router; 在总的js文件中引入该文件，并配置，下面是总的文件 12345678910111213141516const express = require('express');const app = express();const studentRo = require('./router/student.js')//请求体默认为undefined，当解析时才会填充，所以要使用body-parserapp.use(express.urlencoded());app.use(express.json())// 静态文件app.use(express.static('public'));//跨域app.use(function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Content-Type', 'application/json') next();&#125;);app.listen(5000, console.log('Server is running on port 5000'))app.use('/student',studentRo) 使用ejs模板res.render(view[,locals][,callback]) 渲染view视图并将渲染好的html发送给客户端。locals是一个定义一些本地变量的对象，我们可以使用此参数传递数据res.redirect([status,]path) 重定向，状态码默认为302app.set() 可以使用此方法设置模板引擎等 express提供了生成器 全局安装express-generator$ npm install express-generator -g添加对ejs模板的支持$ express -c-f 命令是强制在非空目录下创建 会生成所需要的各类文件和简单的功能 cd到该目录下安装所有的依赖$ npm install 监听的端口默认为3000","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"[原]Es6","slug":"原-Es6","date":"2019-01-02T13:23:51.000Z","updated":"2019-01-07T13:51:40.645Z","comments":true,"path":"2019/01/02/原-Es6/","link":"","permalink":"http://yoursite.com/2019/01/02/原-Es6/","excerpt":"","text":"let声明变量 声明不会提升 不能重复声明（当前作用域下不能有相同变量名），会报错 变量会捆绑在当前的语句块中，也就是说只在当前块级作用域下生效 const声明常量 声明不会提升 不能重复声明，会报错 在声明常量时，必须要赋值，否则会报错 一经赋值不可修改 函数参数的默认值 function(color = ‘red’){} red为color的默认值 箭头函数 var max = function(){} var max = () =&gt; {} 这行代码等价与上面的代码 当代码简洁时，可以把大括号去掉简写为一行 eg：var max = (x,y) =&gt; x&gt;y?x:y; =&gt; 后面的代码为return的值，但不能写return 如果函数的参数不止一个或没有，要用小括号包着，如果只有一个参数，可以省略括号。 箭头函数中没有this，如果使用this是指向window的 剩余操作符 … 我们可以在形参名前加上…来让它接受剩余的参数，当不确定实参个数时，这是个很好的选择。 12345function sum(a,b,…others)&#123;&#125;sum(1,2,3,4,5,6,7)//a=1,b=2,others就等于一个数组，里面包含所有剩下的实参，也就是[3,4,5,6,7] 展开操作符… 我们可以在数组名前加上展开操作符，那么他就会显示数组中的各个元素 eg: let arr1 = [1,2,3] console.log(…arr1) 控制台会打印1,2,3 我们也可以使用这个操作符来复制/合并数组 复制：let arr2 = […arr1] 合并：let arr2 = […arr1,4,5] 模板字面量 使用模板字面量来定义字符串，可以使用${}在字符串中插入内容，在括号中可写变量或表达式 并且在模板字面量中换行，会保留格式，换行和tab键都会放在字符串中 var str = ` ` 对象的属性简写 当属性值和属性名相同时，可简写为一个变量名 12345var name = '李四'var obj = &#123; name//这里的name值为李四&#125; 数组解构123let colors= [ 'red','green','blue'];let [firstC,secC,thirdC] = colors;// 上面的变量的值按顺序依次为数组中的颜色 当为变量重新赋值时，只需将let 去掉即可。 为变量设置默认值，与函数形参默认值方法相同。 嵌套数组解构12let colors= [ 'red','green','blue',['violet','white']];let [firstC,secC,thirdC,[,lastC]] = colors; 对象解构 12let obj1= &#123;name:'lisi',age:20&#125;;let &#123;name,age&#125; = obj1; 与数组解构不同的是,上面这种方法只能当变量名和对象的属性名相同使可以使用，如果要为非同名的变量赋值，要写为以下的方式 1let &#123;name:myName,age:myAge&#125; = obj1; 前面的是对象中的属性名，后面的为我们设置的变量名，相当于为变量指明要从哪里找值。 默认值：与函数形参的默认值的传值方式相同 为变量重新赋值：因为JavaScript不允许赋值操作符左边出现花括号，所以我们要将整个赋值语句用小括号包裹起来，将赋值语句变为一个表达式。 1(&#123;name:myName,age:myAge&#125; = obj1;) 模块 导出：export {名称} /export 函数/变量 导出时重命名：export{旧名字 as 新名字} 导出默认值：123export default 名称export &#123; 名称 as default &#125;export default 名称 导入：import {名称} from 文件路径 导入所有： import *as 名称 from 文件路径 用这个名称来使用，是一个对象，所有模块导出的东西都在里面 导入时重命名：import {旧名字 as 新名字} from 文件路径 导入默认值：import 名称 from 文件路径 默认值会被自动绑定到此名称上 一个模块的默认值只能有一个。 如果在一个js文件中导入模块，但并不使用它，可以再导出，起桥梁作用export {名称} from 文件路径 如果一个文件中没有导入或导出，只是修改了一些全局方法，那么我们在另一个页面导入是，应该：import 文件路径","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"Es6","slug":"Es6","permalink":"http://yoursite.com/tags/Es6/"}]},{"title":"[转]Evevt Loop 事件循环","slug":"转-Evevt-Loop-事件循环","date":"2019-01-02T12:26:40.000Z","updated":"2019-01-03T10:47:00.316Z","comments":true,"path":"2019/01/02/转-Evevt-Loop-事件循环/","link":"","permalink":"http://yoursite.com/2019/01/02/转-Evevt-Loop-事件循环/","excerpt":"","text":"今天在看es6的promise的时候，看了一个很有意思的面试题，牵扯到了setTimeout的执行顺序，总结一下 贴一下面试题的链接 Excuse me？这个前端面试在搞事！ - Liril的文章 - 知乎https://zhuanlan.zhihu.com/p/25407758 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 setTimeout 如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立即执行，相反会把它放到队列中去，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。（setTimeout和setInterval经常有不守时的时候）。 setTimeout并不是真正的异步操作，只是把想执行的代码放到UI队列中，在未来执行 Es6中的Promise，里面的函数是直接执行的，比setTimeout执行的早","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[原]jQuery总结","slug":"原-jQuery总结","date":"2018-12-21T12:54:42.000Z","updated":"2019-01-03T10:43:26.766Z","comments":true,"path":"2018/12/21/原-jQuery总结/","link":"","permalink":"http://yoursite.com/2018/12/21/原-jQuery总结/","excerpt":"","text":"jQuery入口函数$(document).ready(function(){}) $(function(){}) js入口函数与jQ入口函数的区别js函数的入口函数比jq慢,因为js的入口函数会等待页面加载完成,并且外部资源也加载完成后才会执行,但jq 的入口函数等待页面加载完成后就会执行。 js入口函数只能执行一次,会产生覆盖,但jq的可以多次使用 隐式迭代jQuery有隐式迭代的特性,会自动的遍历,设置操作时会给选择到所有的对象都设置上相同的值。在获取值时,如果选择的对象中有多个元素,就只会获取到第一个的值,因为隐式迭代会让jq认为所有的值都为相同的。 链式编程jq的方法都会返回一个对象,所以我们可以一直调用下去。但返回的如果不是当前对象,就不能链式下去。 选择器基本选择器 ID选择器 类选择器 标签选择器 并列选择器 $(&#39;p,span&#39;) 交集选择器 $(&#39;p.box&#39;) 层次选择器 直接子级选择器 后代选择器 后面所有同级 $(“p~span”) 后面紧挨着的同级 $(“p+span”) 筛选选择器（方法） ()里面也可以加选择器 .first() 第一个元素 .last() 最后一个 .children() 相当于子级选择器 .find() 相当于后代选择器 .parent() 父元素 .parents() 祖先元素 .next() 下一个同级 .nextAll() 下面所有的同级 .nextUntil() 往下找,直到选择器为止不包括选择器（相当与一个区间） .prev() 上一个 .prevAll() ` 上面所有的同级 .prevUntil() 往上找,直到选择器,不包含选择器 .siblings() 除自身外所有的同级 .slice() 同数组方法 .filter() 选取满足选择器的元素 .not() 选取不满足选择器的元素 .has() 选取一个元素中有子元素满足此选择器 .is() 判断是否有此元素,如果一个有返回true,如果有多个,返回集合 .closest() 从自身找距离自己最近的元素 .offsetParent() 距离自己最近的定位祖先元素 .eq(index) 选取指定下标的元素 .get(index)方法与此相同,但get()返回的是DOM对象,所以也可以用来将jq对 象转为DOM对象 ,$(dom对象)这种方法可以转为jq对象 过滤选择器 :first 第一个 :last 最后一个 :even 偶数个 :odd 奇数个 :gt(index) 大于索引的 :lt(index) 小于索引的 :contains() 选取内容满足选择器的 :not 不满足选择器的 :visible 可见的元素 :hide 隐藏的元素 :parent 非空元素 :empty 空元素 :has() 选择包含有选择器的元素 :animate 选择正在应用动画状态的元素 :target 选择锚链接的目标位置 :button :checked :selecte :disable :enabled 所有css3的子元素选择器,属性选择器,这里就不过多写了(nth-child等) 使用上下文获取元素 $(“p”,&quot;#box&quot;) 从#box下获取p元素 操作样式css() 传一个参是获取样式值 传一个属性一个值是修改或添加 操作多个可以传对象 操作class .addClass() 添加类 .removeClass() 移除类 .hasClass() 判断是否有这个类 .toggleClass() 切换类,如果有则删除,如果没有则加上 操作属性attr() 与css的传参方式相同 removeAttr() 删除属性 prop() 操作一些属性值为布尔值的属性,例如”checked,disabled等” removeProp() 删除属性 data() 操作自定义属性值 removeData() 删除属性 动画show()和hide() 显示和隐藏 第一个参数是动画执行时间,第二个回调函数 slideDown(),slideUp(),slideToggle()` 划入滑出和切换 fadeIn(),fadeOut(),fadeToggle() 渐入,渐出和切换（改变透明度） animated(property,执行时间,执行效果(swing/linear),回调函数) 动画队列 jq会把动画储存到动画队列中,动画会按照顺序执行,不会丢失。但如果多次快速触发动画,动画执行需要一定时间,当不触发动画时,动画依然会执行,一直等到动画队列结束,为了解决这个问题我们可以使用 stop()方法 stop()方法要在动画前调用,当触发动画时,先停止之前动画,再执行动画效果。 stop()的方法有两个参数,第一个为是否清除动画队列,第二个为是否跳到动画的最终效果,一般情况下我们不会使用这两个参数。 delay(延迟时间,[队列名称]) 推迟动画队列之后的项目 节点操作（增删改复制）创建: $() 添加: append() 添加到目标元素的最后面（作为子元素） 也可以把想要创建的元素直接写在括号中,会先创建后添加 appendTo() 与上的不同在于:目标元素写在括号中 prepend () 添加到目标元素的子元素的最前面 prependTo() 与 appendTo同理 after() 添加到目标元素的下面（作为兄弟元素） innerAfter() before() 添加到目标元素的上面（作为兄弟元素） innerbefore() 替换: replaceWith() 把目标元素替换为括号中的元素 replaceAll() 用括号中的元素替换目标元素 克隆: clone(true) 深复制,不仅复制元素本身及其子元素,还会复制其绑定的事件和数据 clone(true) 浅复制,只复制元素本身及其子元素,不会复制事件及数据 clone(true,false) 复制元素本身及其子元素,但只复制父元素的事件及数据,不复制子元素的事件及数据 只要第一个参数为false,则不管第二个参数是什么,都为false 删除: empty()` 清空元素,但元素自身依旧存在。会解除绑定事件 html(&#39;&#39;) 清空元素,但元素自身依旧存在。但不会清空被清空的元素身上绑定的事件,会造成内存泄露。 detach() 删除元素,自身也会被删除。但此方法不会删除元素身上绑定的事件数据 remove() 删除元素,自身也会被删除。这个方法会删除绑定的事件数据。 删除的这两个方法,都不会删除jq对象,都会返回被删除的元素。我们可以在需要的时候重新添加到页面中。 事件的注册触发解绑注册: on(事件类型,[事件委托的子元素],[传递给事件处理函数的数据,一般使用event,data来回去],事件处理函数) 触发: trigger(事件类型)解绑:off(事件类型)` 特殊属性操作（属性值,高宽）获取或修改表单中的值:val() 传值为修改 获取或修改标签中的值:text() html() 与innerText和innerHTML相同 width() 实际宽度width,返回一个数字,传值可修改 height() 实际高度 innerWidth() width+padding innerHeight() height+padding outerwidth() width+padding+border outerHeight() height+padding+border outerwidth(true) width+padding+border+margin outerHeight(true) height+padding+border+margin scrollTop() 被卷曲出去的高度 scrollLeft() 被卷曲出去的宽度 offset() 获取元素距离document的距离,返回一个对象,里面有top和left的值。如果设置传一个对象,设置之后会给元素加相对定位,改变位置。 position() 获取元素距离有定位父元素的距离,只可获取不能修改 操作集合add() 合并集合,括号内可以是选择器,标签,DOM对象,jq对象 addBack() 将过滤后的对象与上一个合并 contents() 获取对象中每一个元素的内容（文本,注释和标签） index() 返回当前元素在所有兄弟元素里面的索引 end() 返回到上一次的操作 $冲突当jq拿到控制权时,可以使用onConflict()来释放控制权,如果没有控制权可以使用jQuery来代替$ 包裹元素wrap() 使用一个元素包裹每一个被选择到的对象 wrapAll() 使用一个元素包裹所有被选择到的元素 wrapInner() 使用指定标签包裹元素中的内容 unwrap() 删除包裹该元素的元素,也就是父元素,如果括号内传了选择器,如果不满足此选择器,则不会被删除 工具方法$.each(function(索引,属性){}) 遍历 $.each(function(属性名,属性值){}) 遍历 遍历对象时形参为属性名和属性值,数组或jq对象时,形参为索引和属性 $.extend(true/false,obj1,obj2) 将第二个及其以后的对象合并到第一个 第一个值为true是深合并,会合并对象中的对象,false则不会。如果对象中的属性名有相同的,后面的会覆盖前面的。如果属性值出现undefined,则会被忽略。 可以用来复制对象 $.extent({},obj1) $.greg(数组,function(属性,索引){}) 从数组中过滤出满足条件的元素,返回值为布尔值 $.merge(arr1,arr2)` 把第二个数组合并到第一个,这个方法只能有两个参数 $.inArray(要找的元素,去哪个数组找,从索引几开始找(默认0)) 属性是否在数组中,是则返回索引,不是返回-1 $.map(数组/对象,function(元素/属性值,索引/属性名){}) 用指定函数处理对象或数组中的每一个元素,返回值作为数组或对象中的元素,并把结果封装为新的数组或对象,如果返回null/undefined,则不会被添加到数组或对象中 $.makeArray() 把一个类似数组（有集合,下标）的对象转为数组 $.isArray() 判断是否为数组 $.isPlainObject() 判断是否为一个对象 $.isEmptyObject() 判断是否为空对象 $.type() 检测数据类型 与typeof()类似 toArray() 将JQ对象转为数组 AJAX$().load(url,与请求一同发送的查询字符串键/值对集合,回调函数) 从服务器加载数据,并把返回的数据放置到指定元素中 $().getScript(url,回调函数) 使用get方式获取js类型的数据 $().getJSON(url,回调函数) 使用get方式获取quJSON类型的数据 $().get(url,回调函数,期望返回数据的类型) 使用get方式获取指定类型的数据 能接受数据的类型有5种:html,text,JSON,js,xml $().post(url,提交的数据,回调函数,期望返回数据的类型) 使用post方式提交数据 $().ajax(url,各种设置)/ $().ajax(各种设置) 设置:url,data数据,dataType数据类型,timeout超时时间,method提交方式,global :true/false是否触发全局ajax事件处理程序,success回调函数,error回调,complete回调,beforeSend回调 $().ajaxsetup()` 设置下面的ajax请求的默认值","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"[原]jq要注意的点","slug":"原-jq要注意的点","date":"2018-12-08T12:09:21.000Z","updated":"2019-01-10T08:44:39.415Z","comments":true,"path":"2018/12/08/原-jq要注意的点/","link":"","permalink":"http://yoursite.com/2018/12/08/原-jq要注意的点/","excerpt":"","text":"查找下标JQ对象查找指定下标的方法为：eq() get()方法也是查找指定下标的，但返回的是dom元素 eg:今天写一个导航条绑定鼠标进入事件时播放指定音乐，因为JQ中没有封装audio 和 video 的方法，所以play的方法要绑定在DOM元素，这时如果要是使用eq的话就不对了。 一个报错 但是这时报错了Uncaught (in promise) DOMException: play() failed because the user didn’t interact with the document first. 原来在Chrome 4月份更新了版本后，autoplay政策做了更改 解决方法：打开 chrome://flags/#autoplay-policy 把Default修改为 No user gesture is required prop方法prop()方法 是操作元素的属性 attr()方法是操作标签的属性 对于一些特殊的属性 eg: checked, selected ,disabled 这些值为布尔值的属性，无法使用attr方法设置，因为JQ对于未设置的这些特殊属性会返回undefined，所以要用prop方法 用法和attr相同 eg : prop(&#39;checked&#39;,&#39;true&#39;) 动画队列JQ中会把动画放在一个动画队列中。如果调用多个动画，它也会按照顺序挨个执行，不会覆盖，也会把动画保存好，但同时不好的地方也出现了。如果有一个鼠标进入触发动画的函数，用户多次触发并速度很快，那么鼠标离开后 ，它仍然会执行，直到动画队列中的动画执行完。 解决方法：stop()方法 停止正在执行的动画 在动画方法前调用此方法就可以解决动画队列的问题。 stop(clearQueue,jumpToEnd) 参数值都为布尔型 clearQueue : 是否清除动画队列 jumpToEnd : 是否跳转到当前动画的最终效果 不传参默认都为 false。 index()方法JQ中的index()方法会返回当前元素在所有兄弟元素中的索引123&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt;//如果给a标签使用index()方法就只会显示0,要对li标签使用此方法 删除节点remove()和detach()都是删除节点。 区别：remove方法会删除自身元素及其内容，也会删除事件监听和数据。 detach方法只删除元素本身及其内容。 两种方法都会保留 jQuery 对象中的匹配的元素，返回的是被选择的这个元素，所以可以在将来再使用这些匹配的元素。 所以在进行大规模的增删改时我们可以先把一个元素提取出来，在此元素上面进行操作，在重新添加到页面中，就减少了对DOM的操作的修改，从而减少了页面重绘，但是这种时候最好使用detach()方法，因为此方法不会删除自身的事件及数据。 data方法从1.4.3开始我们通过自定义属性给元素绑定数据，也会被自动的添加到jQuery的数据对象中，因此我们也可以通过data方法操作。 获取：.data(属性名) 不传参是获取所有的 设置：data(属性名：属性值) 删除：removeData(属性名) 事件委托我们可以使用on方式来绑定简单的事件 eg：$(&#39;#box&#39;).on(&#39;click&#39;,function(){}) 但是如果我们的页面中动态添加的元素不会被绑定到此事件，所以我们可以使用事件委托的方式； 语法：父元素.on(事件类型,事件委托的子元素，传递给处理函数的数据，事件处理函数) 原理：通过给父元素注册事件委托，但子元素身上其实是没有事件的。利用了事件冒泡，触发父元素事件，把事件分发给了子元素，最终还是由子元素执行的。支持动态创建添加的元素。 传递的数据：传递给处理函数的数据，事件触发时可以通过event.data来使用 克隆节点clone(true) 深复制，复制自身及其子元素，并复制其事件和数据 clone(false) 浅复制，复制自身及其子元素，不复制其事件和数据 clone(true，false) 复制自身及其子元素，并复制父元素的事件和数据但不会复制子元素的事件和数据 只要第一个参数为false，则无论第二个参数无论设置成什么，都为false $冲突如果我们一个页面引入多个框架，可能会导致$冲突的问题，默认后面会覆盖前面的，那么在jQuery拿到控制权的前提下，jQuery给我们提供了释放$控制权的方法。 $.noConflict() 我们可以使用一个变量来接受一下，用来代替$ 在没有控制权时也可以使用jQuery来代替$ 制作jQuery插件我们可以通过给$.fn添加方法开扩展jQuery对象 $.fn等价于jQuery.prototype`","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"[原]关于属性","slug":"原-关于属性","date":"2018-12-04T13:19:42.000Z","updated":"2019-01-03T10:49:59.163Z","comments":true,"path":"2018/12/04/原-关于属性/","link":"","permalink":"http://yoursite.com/2018/12/04/原-关于属性/","excerpt":"","text":"对象的增删改查123456789101112131415161718// 使用字面量的形式实例化 Object 对象var obj1 = &#123; myName: '周正国'&#125;;添加属性obj1.age = 20;obj1['gender'] = '男';修改属性的值obj1.age += 1;访问属性obj1['myName']obj1.myName删除属性delete obj1.age; 遍历对象中的属性 for in 遍历 Object.keys(要遍历的对象)构造函数.方法=function(){} 可以不用实例化对象就可以通过构造函数.方法（）来调用，如上。 对象属性 数据属性 保存的是数据 属性名：属性值的方式 访问器属性 通常用于隐藏数据 用get，set 方法来获取或者设置属性 对象的方法 判断一个属性是否在对象中 in 操作符 属性名 in 对象名 hasOwnProperty() 对象名.hasOwnProperty（属性名） 区别：2只会在对象的自有属性列表中查找，而1不仅会在自有属性列表下查找，还会沿着原型链查找。 判断某个属性是否可枚举 对象.propertyIsEnumerable() 判断一个对象是否是另一个对象的原型 原型.isPropertyOf(对象) 属性的特性 获取属性的特性 我们可以通过以下方式获取一个或多个属性的特性 Object.getOwnPropertyDescriptor(对象名,要获取的属性名) 获取对象中该属性的特性 Object.getOwnPropertyDescriptors（对象名） 获取对象中所有的属性的特性 如下图代码打印一下它们获取到的特性 12345678910111213var student=&#123; studentName:\"大雨\", age:20, play:function()&#123; console.log(\"打豆豆\") &#125; &#125;var stu1=Object.getOwnPropertyDescriptor(student,\"age\");var stu2=Object.getOwnPropertyDescriptors(student); console.log(stu1); console.log(stu2); 可以看到得到的是一个对象，那么可以看到它的特性有四个 configurable 是否可配置 enumerable 是否可枚举 value 属性值 writable 是否可写当然它们默认都是 true 。我们也可以去控制这些特性。 控制属性的特性 Object.defineProperty(对象名，属性，{修改特性的值 }) —–&gt; 控制一个属性的值 Object.defineProperties(对象名，{属性名：{修改特性的值},属性名：{修改特性的值}}) —–&gt; 控制一个属性的值Object.defineProperty(student,\"age\",{ value:18, configurable:false, enumerable:false, writable:false }) Object.defineProperties(student,{ gender:{ value:\"女\", configurable:true, enumerable:false, writable:false }, num:{ value:01, configurable:false, enumerable:false, writable:true } }) console.log(Object.getOwnPropertyDescriptor(student,\"age\")) console.log(Object.getOwnPropertyDescriptors(student) 所以我们也可以利用这种方式添加属性或者修改属性值，同时设置属性的特性 禁止对象扩展查询对象是否可被扩展 Object.isExtensible(要查询的对象名) 默认都为true。 禁止对象扩展 Object.preventExtensions(要禁止的对象名) 禁止对象扩展的特性：不可向对象中添加新的属性 对象封印判断对象是否被封印 Object.isSealed(要查询的对象名) 封印对象 Object.seal(要封印的对象名) 对象被封印后的特性：不可删除属性，不可添加新属性，可以修改属性值。 所有被封印对象的属性的特性都被设置了：configurable: false 冻结对象判断对象是否被冻结 Object.isFrozen(要查询的对象名) 封印对象 Object.freeze(要封印的对象名) 对象被封印后的特性：不可删除属性，不可添加新属性，不可修改属性值。","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[原]继承","slug":"原-继承","date":"2018-12-01T11:08:10.000Z","updated":"2019-01-10T08:45:49.597Z","comments":true,"path":"2018/12/01/原-继承/","link":"","permalink":"http://yoursite.com/2018/12/01/原-继承/","excerpt":"","text":"定义面向对象的特性：封装，继承，多态。 继承是类与类之间的关系，在面向对象的语言中是为了多态服务的。而js不是一门面向对象的语言，没有类的概念，但是我们可以模拟面向对象，模拟继承。继承是一种父类级别与子类级别的关系。 方法1、原型继承—-&gt;改变原型的指向 原型的作用是数据共享，目的是为了节省内存空间，那么在这我们可以知道原型的另一个作用：继承。所以，继承的作用也是为了节省内存空间。 缺陷：因为在改变原型指向的同时初始化了属性，那么继承的属性值都是相同的，只能调用对象的属性重新赋值，这样就 太过于浪费时间了。 2、借用构造函数继承 —&gt; call()方法 缺陷：不会继承原型中添加的方法 3、组合继承 —&gt; 原型继承+借用构造函数继承 改变指向时不初始化属性，既解决了属性问题又解决了方法问题。 4、拷贝继承 —&gt; 把需要共享的属性及方法，通过for in遍历的方式复制到另一个属性中 补充 5、对象继承 —&gt; 可以使用这种方法创建对象，同时指定新对象的原型指向，并且可以设置属性的特性，较为灵活。12345678Object.creat(要指向的原型，&#123; 属性值：&#123; value：值， enumerable:true/false, configurable:true/false, writable:true/false &#125; &#125;);","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[原]原型和原型链","slug":"原-原型和原型链","date":"2018-12-01T01:02:01.000Z","updated":"2019-01-07T13:51:34.110Z","comments":true,"path":"2018/12/01/原-原型和原型链/","link":"","permalink":"http://yoursite.com/2018/12/01/原-原型和原型链/","excerpt":"","text":"定义实例对象中有proto这个属性，叫原型，也就是一个对象。这个属性是给浏览器使用的，不是标准的属性。 构造函数有prototype这个属性，也是原型。这个属性是给程序员使用的，是标准的属性。—&gt;它们都可以叫原型对象。 获取对象的原型的值 实例对象.proto 构造函数.prototype Object.getPrototypeof(对象名) 实例化对象，构造函数和原型对象三者的关系1、构造函数可以实例化对象。实例对象是通过构造函数创建的，创建的过程叫实例化，如果传参，就是对属性进行初始化。 2、构造函数中有一个prototype这个属性，是构造函数的原型对象。 3、原型对象中有一个构造器（constructor），构造器指向的是它所在的原型对象所在的构造函数。 4、实例对象的原型对象指向的是它所在的构造函数的原型对象。实例化对象.proto==构造函数prototype —-&gt;true。 5、构造函数的原型对象中的方法可以直接被实例对象直接访问。 6、原型对象中的方法可以互相调用。 7、实例对象所使用的方法或属性，首先在实例中查找，找到了直接使用，如果找不到则去实例对象的原型对（proto）所指向的原型对象（prototype）中找，找到了使用，找不多就报错。 原型的指向是可以改变的12345678910111213function Animal()&#123;&#125;Animal.prototype.eat=function()&#123;console.log(\"Animal的吃\")&#125;function Person()&#123;&#125;Person.prototype.play=function()&#123;console.log(\"Person的玩\")&#125;Animal.prototype=new Person();var sheep=new Animal();sheep.eat（） 此时代码会报错，因为把Animal的原型指向了Person的原型，那么sheep将不能调用Animal原型里面的方法。 因为实例对象的原型（proto）指向的是该对象所在的构造函数的原型对象（prototype），构造函数的原型对象（prototype）如果改变了，实例对象（proto）的指向也会改变。 同时Animal也继承了Person。 那么如果又想改变指向，又想访问到方法，解决方法：在原型改变后再添加方法 原型的简单写法12345678910111213构造函数.prototype=&#123;//需要手动修改构造器的指向constructor:构造函数；属性：属性值；方法：function（）&#123;&#125;&#125; 这样的写法也是改变了原型指向，让原型指向了一个对象，所以，如果先在原型上添加了一个方法，在使用此方式添加属性和方法，那么在原型上添加的方法将不会被访问到。解决方法：同上 原型链定义原型链是实例对象和原型对象通过原型（proto）来联系的一种关系。是通过原型继承，形成了一个链条。 原型链的最终指向实例对象.proto—&gt;构造函数.prototype 实例对象.proto.proto—&gt;构造函数.prototype.proto 构造函数.prototype.proto—&gt;object.prototype object.prototype.proto—&gt;null 所以object.prototype是顶层","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[原]flex box布局","slug":"原-flex-box布局","date":"2018-11-26T12:31:14.000Z","updated":"2019-01-03T10:42:53.602Z","comments":true,"path":"2018/11/26/原-flex-box布局/","link":"","permalink":"http://yoursite.com/2018/11/26/原-flex-box布局/","excerpt":"","text":"给父级元素设置display：flex会使之转成弹性盒模型，为我们提供了简单方便的设置盒子水平垂直居中的方法。 设置主轴（水平）方向居中 justify-content : flex-start （默认值）主轴起始点位置对齐（水平方向左对齐） flex-end 主轴的结束位置（水平方向右对齐） center 居中对齐 space-between 两端对齐，项目之间的间隙相等 space-around 项目之间的间隙比项目到边框的间隙大一倍，与 space-between 的区别在于此方式两端会有一定的空隙，而 space-between 项目是紧挨着边框的 设置交叉轴（垂直）上的对齐方式 align-items： stretch （默认值） 当子元素盒子没有设置高度或设置为auto时，垂直方向自适应，也就是高度会填充满父元素 flex-start 交叉轴起始点位置对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中点对齐 baseline 基于第一行文字的基线对齐 多行沿交叉轴对齐（多行轴线的对齐方式）如果只有一根轴线，不起作用 align-content : flex-start 与交叉轴的起点对齐 flex-end 交叉轴的终点对齐 center 交叉轴的中间对齐 space-between 交叉轴两端对齐，均匀分布 space-around 多行中行与行之间的上下距离是最上或最下一行距离上下边框距离的一倍，也就是相当于上图倒过来的效果 那么如果想设置一个盒子垂直水平居中的话就可以给他的父级元素设置： display：flex justify-context : center align-item : center 关于子容器的操作方式目前只接触了 设置子容器空间的分配方法flex，收藏了关于这些的一些文章","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"[原]自定义构造器函数","slug":"原-自定义构造器函数","date":"2018-11-26T04:30:00.000Z","updated":"2019-01-10T08:46:00.696Z","comments":true,"path":"2018/11/26/原-自定义构造器函数/","link":"","permalink":"http://yoursite.com/2018/11/26/原-自定义构造器函数/","excerpt":"","text":"总结笔记自定义构造器函数相当于一个模板，需要的时候去引用它，函数内没有new和返回值，this是当前对象。 通过new的方式开创建对象，也就是实例化对象，同时对属性进行初始化 实例化对象的构造器（constructor）是指向构造函数的。所以，实例对象是通过构造器函数来创建设的，这个创建的过程教实例化。 判断这个对象是否属于这种数据类型的方式有两种： 1、通过构造器方式————&gt;实例对象.constructor==构造函数 2、instanceof 方式（尽可能使用这种方式）123456789function Person(name,age)&#123; this.name=name; this.age=age; this.eat=function ()&#123; consolo.log(\"吃\") &#125; &#125;var per=new Person(\"li\" ,18)per.eat() 上面的eat（）是一个方法，如果多次创建对象，那么创建的对象中的eat方法不是同一个，所以就会占用大量内存空间， 所以要使用原型。 那么原型的作用之一就是 —&gt; 数据共享，节省内存空间","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[转]全局捕获","slug":"转-全局捕获-1","date":"2018-11-15T01:15:18.000Z","updated":"2019-01-07T13:34:29.658Z","comments":true,"path":"2018/11/15/转-全局捕获-1/","link":"","permalink":"http://yoursite.com/2018/11/15/转-全局捕获-1/","excerpt":"","text":"全局捕获的理解全局捕获只支持鼠标事件，不支持键盘事件。 全局捕获： 全局（包含浏览器外）出现一个鼠标事件，会被设置全局捕获的对象捕获，如果此对象正好有对应的事件函数， 那么会被触发，而最初的发起事件的元素就不会执行它的事件函数了，通俗点说就是事件被掠走了。 全局捕获只能执行一次捕获的事件，如果持续捕获可能会出现问题，可以想象下： 如果全局捕获点击事件，鼠标无论点击哪里都会执行那段代码，那么连最基本的关闭浏览器窗口都不行了。 如果持续捕获，必须有取消全局捕获。 作者：jerny2017 来源：CSDN 原文：https://blog.csdn.net/jerny2017/article/details/80282502 setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理。这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰 另外，还有一个很重 要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。 所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事 件已经不再发给这个圆点对象了。 web开发和windows开发最大的区别就是windows开发是有状态的，而web开发是无状态的，在windows中，一切操作都可以由程序来控制 ，除非强制执行ctrl+alt+del；但web操作就不一样了，即使执行很重要的操作，用户一点击浏览器关闭按钮，就将前面操作成果化为乌有.尽管可以在onunload事件中加些代码，让用户可以选择是否退出，但不能从根本上解决问题! 前几天，从网上看到setCapture方法，了解了一下，大体是这样的意思，当在IE文档某个区域中使用了这个方法，并且写了onclick或者 onmouse***等有关的鼠标事件方法，那么它就会监视相应的鼠标操作，即使你的鼠标移出了IE，它也一样能捕获到.如果你在某div中的 onclick事件中写了一个alert命令，这时，你点击的关闭按钮，它也一样会弹出alert窗口.releaseCapture与 setCapture方法相反，释放鼠标监控. 利用这个特性，我们可以延缓IE的关闭窗口等破坏性操作，将一些重要的操作能够在破坏性操作执行之前得到处理. 有一点遗憾:setCapture和releaseCapture 不支持键盘事件.只对onmousedown， onmouseup， onmousemove， onclick， ondblclick， onmouseover， onmouseout这样的鼠标事件起作用.","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[转]call（），apply（）和bind（）","slug":"转-call（），apply（）和bind（）-1","date":"2018-11-14T14:07:44.000Z","updated":"2019-01-10T08:46:13.393Z","comments":true,"path":"2018/11/14/转-call（），apply（）和bind（）-1/","link":"","permalink":"http://yoursite.com/2018/11/14/转-call（），apply（）和bind（）-1/","excerpt":"","text":"今天对于call方法和apply方法有些懵，所以去看了些别人的总结，感觉有了点概念，把一些大佬写的东西中自己感觉易懂的解释和经典的案例记录一下。 定义call方法: 语法：call([thisObj][,实参]) 定义：调用一个对象的一个方法，以另一个对象替换当前对象。 说明： call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。（ 第一个借用别人的函数，第二个借用别人的上下文环境。） 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 用括号的第一个参数来代替this的指向 call（） 就是用来让括号里的对象 来集成括号外的函数的属性！可以称之为继承！ apply方法： 语法：apply([thisObj[,argArray]]) 定义：应用某一对象的一个方法，用另一个对象替换当前对象。 说明： 如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数 作用相同，只是书写格式不同 call方法案例12345678function add(a,b)&#123; alert(a+b);&#125;function sub(a,b)&#123; alert(a-b);&#125;add.call(sub,3,1); 个人理解call和apply的作用就是切换函数的对象上下文。 这个例子中的意思就是用 add 来替换 sub“，应该是将add执行的上下文由window切换为sub，即this指向是从window变为sub，仅此而已，并非add替换sub。这个例子很难说明什么。 其实就是call方法前面的东西(add)都交给后面(sub)了，就像兄弟，接过这把枪。 add.call(sub,3,1) // sub 已经接过了add方法12345678910111213141516171819function Animal()&#123; this.name = \"Animal\"; this.showName = function()&#123; alert(this.name); &#125; &#125; .function Cat()&#123; this.name = \"Cat\"; &#125; var animal = new Animal(); var cat = new Cat(); //通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。//输入结果为\"Cat\"//animal.showName.call](//animal.showName.call)(cat,\",\");//animal.showName.apply](//animal.showName.apply)(cat,[]); call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name应该是 Cat。 关于javascript中call和apply函数的应用 关于类的初始化应用如下：复制代码 代码如下:1234567891011121314151617181920Person = function() &#123; this.Init.apply(this, arguments); &#125;; Person.prototype = &#123; first: null, last: null, Init: function(first, last) &#123; this.first = first; this.last = last; &#125;, fullName: function() &#123; return this.first + ' ' + this.last; &#125;, fullNameReversed: function() &#123; return this.last + ', ' + this.first; &#125; &#125;; var s = new Person2('creese', 'yang'); alert(s.fullName()); alert(s.fullNameReversed()); call和apply函数可以赋值函数内容（带匿名参数；但不触发） call和apply函数关于函数绑定参数应用如下： 复制代码 代码如下:1234567891011Function.prototype.Bind = function() &#123; var __m = this, object = arguments[0], args = new Array(); for(var i = 1； i &amp;lt; arguments.length； i++)&#123; args.push(arguments[i]); &#125; return function() &#123; return __m.apply(object, args); &#125; &#125; call和apply函数功能是一样的；就是参数格式不同；fun.call(obj， arguments)；apply的arguments是数组形式；call则是单数形式。 bind()方法bind与前两个不同，前两个是改变this的指向，而bind是绑定this的指向，返回的是一个this指向为你所绑定的一个新函数，而原本的函数并没有改变。并且，call和apply改变this指向时会自动调用此函数，但bind不会，需要手动去调用并传参。如果在绑定this指向时传参，那参数的值就不能再改变。 语法 bind（this指向）","categories":[{"name":"前端笔记","slug":"前端笔记","permalink":"http://yoursite.com/categories/前端笔记/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]}]}