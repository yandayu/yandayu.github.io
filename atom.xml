<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hey 这里是闫大雨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-12T03:31:16.548Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[原]less</title>
    <link href="http://yoursite.com/2019/01/10/%E5%8E%9F-less/"/>
    <id>http://yoursite.com/2019/01/10/原-less/</id>
    <published>2019-01-10T12:23:51.000Z</published>
    <updated>2019-01-12T03:31:16.548Z</updated>
    
    <content type="html"><![CDATA[<p><strong>我们在项目中使用less时，可以分开创建各个类型，创建一个专门保存变量的less 文件，一个混入方法的文件等，有利于以后的维护</strong></p><p><strong>声明编码类型防止乱码</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@charset</span> <span class="string">"utf-8"</span>;</span><br></pre></td></tr></table></figure></p><p><strong>变量</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*必须@前缀,;结尾,:为等于。变量名不能以数字开头，不能包含特殊字符，区分大小写 */</span></span><br><span class="line"><span class="variable">@textColor:</span><span class="number">#333</span>;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@textColor</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 也可以用来声明一个类名，但变量与其他字符拼接时，要加&#123;&#125;来表明哪个是变量 */</span></span><br><span class="line"><span class="variable">@className:</span>box;</span><br><span class="line"><span class="selector-class">.@&#123;className&#125;</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="variable">@textColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>mixin混入</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类混合，这种方式类也会被编译进css中，但是我们不会使用，所以使用函数的形式 */</span></span><br><span class="line"><span class="selector-class">.h50</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.f_r</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.h50-f_r</span>&#123;</span><br><span class="line">    <span class="selector-class">.h50</span>;</span><br><span class="line">    <span class="selector-class">.f_r</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定义函数，函数不会被编译进css中 */</span></span><br><span class="line"><span class="selector-class">.w50</span>()&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 传参的函数，如果没有默认值，使用时必须要传参;不传参时不写括号</span></span><br><span class="line"><span class="comment">    默认值写法与变量写法相同 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.f</span>(<span class="variable">@direction</span>:left)&#123;</span><br><span class="line">    <span class="attribute">float</span>: <span class="variable">@direction</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.w50-f</span>&#123;</span><br><span class="line">    <span class="selector-class">.w50</span>;</span><br><span class="line">    <span class="selector-class">.f</span>(right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="selector-tag">img</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 需要连接时使用：&amp; */</span></span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="selector-tag">img</span>&#123;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 会解析为以下形式*/</span></span><br><span class="line">   <span class="selector-class">.header</span>&#123;</span><br><span class="line">       <span class="attribute">display</span>:block</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="selector-class">.header</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">       <span class="attribute">display</span>:none</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="selector-class">.header</span><span class="selector-pseudo">:hover</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">       <span class="attribute">display</span>:block</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用@import 导入文件</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"./main.less"</span>;</span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="variable">@bgc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>转义：~””,放在此引号中的任何东西都会被转义，原样输出</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@minw:</span> <span class="string">~"(min-width:768px)"</span>;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="keyword">@media</span> <span class="variable">@minw</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>并且指令会冒泡，为以下形式</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width</span>:<span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>命名空间</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#group1</span>()&#123;</span><br><span class="line">    <span class="selector-class">.btn</span>&#123;</span><br><span class="line">        <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用时 */</span></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">button</span>&#123;</span><br><span class="line">    <span class="selector-id">#group1</span> &gt;<span class="selector-class">.btn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>循环</strong><br>mixin可以调用本身，结合Guard和模式匹配，可以创建各种循环/迭代的结构。<br>下面是官网给的例子，when是当条件满足时执行函数<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.loop</span>(<span class="variable">@counter</span>) <span class="keyword">when</span> (<span class="variable">@counter</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-class">.loop</span>((<span class="variable">@counter</span> - <span class="number">1</span>));    <span class="comment">// next iteration</span></span><br><span class="line">  <span class="attribute">width</span>: (<span class="number">10px</span> * <span class="variable">@counter</span>); <span class="comment">// code for each iteration</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="selector-class">.loop</span>(<span class="number">5</span>); <span class="comment">// launch the loop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在做移动端rem适配时使用了此方法，便于维护，并且用到了几个内置函数</strong><br>less的变量可以定义数组：<code>@deviceList:750px,640px,340px;</code><br>拿数组的长度length()：<code>@len:length(@deviceList)</code><br>拿数组中的数据extract()<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@index:</span><span class="number">1</span>;</span><br><span class="line"><span class="selector-tag">extract</span>(<span class="variable">@deviceList</span>,<span class="variable">@index</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;我们在项目中使用less时，可以分开创建各个类型，创建一个专门保存变量的less 文件，一个混入方法的文件等，有利于以后的维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明编码类型防止乱码&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="less" scheme="http://yoursite.com/tags/less/"/>
    
  </entry>
  
  <entry>
    <title>[原]gulp</title>
    <link href="http://yoursite.com/2019/01/09/%E5%8E%9F-%E4%BD%BF%E7%94%A8gulp%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/01/09/原-使用gulp搭建自动化环境/</id>
    <published>2019-01-09T13:44:51.000Z</published>
    <updated>2019-01-10T08:45:13.518Z</updated>
    
    <content type="html"><![CDATA[<p><strong>基于node的工具，要确保安装了node</strong></p><ol><li>全局安装gulp 的命令行  <code>$ npm install gulp-cli -g</code></li><li>创建一个项目并切到该文件夹中   <code>$ mkdir   文件名 &amp;&amp; cd 文件名</code></li><li>初始化（会多一个package.json的文件，所有设置及依赖会显示在该文件中），会问你几个关于项目的名称版本等问题，如果使用默     认的，可以再后面加-y，就会直接创建。  <code>$ npm init  -y</code></li><li>作为项目依赖安装gulp   <code>$ npm install gulp -D</code></li><li>创建一个gulpfile.js的文件，如果文件名不为此名称，需要在package.json中修改main的值为对应的名称。可以在json文件中添加 “private”: true ，让项目成为私人的。</li><li>在gulpfile.js文件中引入gulp及所需要的src,dest,pipe,series,watch一系列内置插件</li><li>安装压缩混淆js文件的插件（gulp-uglify），压缩html文件的插件（gulp-htmlmin），压缩css文件的插件（gulp-cssnano），服务器的插件（gulp-connect），都引入到文件中</li><li>创建压缩混淆js文件的任务</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//压缩混淆js   有返回值的不用回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">script</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> src(<span class="string">'src/js/*.js'</span>)</span><br><span class="line">         .pipe(uglify())</span><br><span class="line">         .pipe(dest(<span class="string">'dist/js'</span>))</span><br><span class="line">         .pipe(connect.reload())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用src方法找到要压缩混淆的文件，pipe方法为管道传输，传输过程中使用压缩混淆的方法处理后，<br>（dest方法为输出）处理后输出到dist文件下的js文件下，最后自动刷新<br>压缩html和css方法除了所用的插件不一样外，都相同。</p><ol start="9"><li>任务创建完成后，使用watch方法监听三个任务，任务中如果没有返回值要添加一个回调</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听文件变更</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchFile</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    watch(<span class="string">'src/**/*.js'</span>,script)</span><br><span class="line">    watch(<span class="string">'src/**/*.css'</span>,css)</span><br><span class="line">    watch(<span class="string">'src/*.html'</span>,html)</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>之后创建服务器的任务，监听dist目录的文件，和8080的端口，保持刷新</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实时刷新</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">serve</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    connect.server(&#123;</span><br><span class="line">        root:<span class="string">'dist'</span>,</span><br><span class="line">        port:<span class="number">8080</span>,</span><br><span class="line">        livereload:<span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>最后把监听与服务器的任务导出到默认值中，当执行任务时两个任务都会执行</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出</span></span><br><span class="line">exports.default = series(serve,watchFile)</span><br></pre></td></tr></table></figure><ol start="12"><li>使用node 执行该任务（因为设置了默认值，所以不用写任务名）  gulp ，接下来在浏览器中访问localhost：8080，项目所做的变化，保存页面后就会自动刷新，并且自动压缩。</li></ol><p>如果觉得npm下载包太慢，可以使用淘宝镜像<br><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>执行此命令后，以后的npm操作就要以cnpm代替npm</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;基于node的工具，要确保安装了node&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局安装gulp 的命令行  &lt;code&gt;$ npm install gulp-cli -g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个项目并切到该文件夹中   &lt;code&gt;
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>[原]express</title>
    <link href="http://yoursite.com/2019/01/09/%E5%8E%9F-experss/"/>
    <id>http://yoursite.com/2019/01/09/原-experss/</id>
    <published>2019-01-09T09:23:51.000Z</published>
    <updated>2019-01-10T09:27:43.371Z</updated>
    
    <content type="html"><![CDATA[<p><strong>express是一个基于node.js的web开发框架</strong></p><p> 首先要安装express插件并引入到js文件中，express是一个函数，所以要调用，调用后会返回一个实例（appplication），<br> 使用实例的一些方法来完成我们的项目。</p><p> <strong>express有四种方法，前三种为中间件方法</strong>：</p><ol><li><code>express.static(root[,option])</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 托管静态文件</span><br><span class="line">app.use(express.static(&apos;public&apos;));</span><br></pre></td></tr></table></figure></li></ol><p>app为express的实例，因为托管静态文件是中间件方法，所以使用了它的use方法</p><ol start="2"><li><p><code>express.json</code><br>这个方法是用来解析请求体的内容（解析application/json编码类型的数据），因为请求体中默认为空，当解析时才会被填充</p></li><li><p><code>express.urlencoded([options])</code><br>与上个方法一样，只是用来解析application/x-www-form-urlencoded”编码类型的数据。这两中方法都要在版本v4.16.0 以上才能使用。如果版本低，可以使用body-parser插件来解析</p></li><li><p><code>express.Router([options])</code><br>创建一个路由器对象，当一个js文件中有多种类型的接口时，我们可以把一种类型的拿出来，放在另一个js文件中，引入需要的插件，使用router实例代替app实例调用各种方法，最后导出整个页面。</p></li></ol><p><strong>response方法（只列出了用到的方法，具体官网查询）</strong></p><p><code>response.send()</code>  向浏览器发送消息<br><code>response.end()</code>    结束响应的进程<br><code>response.status()</code>  设置响应的HTTP状态<br><code>response.header()</code>  设置响应头</p><p><strong>request</strong></p><p><code>request.body</code>    请求体</p><p><strong>application</strong></p><p><code>app.METHOD(path，callback)</code>    METHOD可以为get,post,put等，使用指定的回调函数将HTTP请求路由到指定的路径。<br>实际方法：app.get(path，callback)<br><code>app.listen(port[,callback])</code>    监听指定端口<br><code>app.use([path,] callback [, callback...])</code>   安装指定的中间件在指定路径上执行的一个或多个函数当所请求路径的匹配时执行中间件函数。</p><p><strong>router</strong></p><p><code>router.METHOD(path, [callback, ...] callback)</code>   METHOD可以为get,post,put等，与app方法同理</p><p><strong>使用了node 的fs文件系统</strong></p><p>fs.readFile(path[,options],callback)     读取文件，回调中有err和data的参数<br>fs.writeFile(path[,options],callback)     写文件，回调中有err的参数</p><p> <strong>实例</strong><br> 下面是专门写接口的js文件，因为太长，所以只列出了获取和添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.Router();</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">//json文件所在路径</span></span><br><span class="line"><span class="keyword">const</span> stuAdd = <span class="string">'./../data/students.json'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line">router.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//读取文件，并返回给浏览器</span></span><br><span class="line">    fs.readFile(path.join(__dirname + stuAdd), <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.send(err)</span><br><span class="line">        &#125;</span><br><span class="line">        res.status(<span class="number">200</span>).send(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 创建</span></span><br><span class="line">router.post(<span class="string">'/create'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//设置id等数据</span></span><br><span class="line">    <span class="keyword">let</span> newS = &#123;</span><br><span class="line">        id: <span class="built_in">Date</span>.now(),</span><br><span class="line">        name: req.body.name,</span><br><span class="line">        age: req.body.age,</span><br><span class="line">        gender: req.body.gender,</span><br><span class="line">        clazz: req.body.clazz,</span><br><span class="line">        address: req.body.address,</span><br><span class="line">        creat: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString(),</span><br><span class="line">        update: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleString()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//读取文件并把新的内容传入json文件</span></span><br><span class="line">    fs.readFile((__dirname + stuAdd), <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//如果有错，抛出错误，防止格式错误</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> res.status(<span class="number">200</span>).send(error)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data.push(newS)</span><br><span class="line">        <span class="comment">//把新数据传入json文件</span></span><br><span class="line">        fs.writeFile(path.join(__dirname + stuAdd), <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">4</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            res.status(<span class="number">200</span>).send(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//导出整个页面</span></span><br><span class="line">exports = <span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure><p>在总的js文件中引入该文件，并配置，下面是总的文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> studentRo = <span class="built_in">require</span>(<span class="string">'./router/student.js'</span>)</span><br><span class="line"><span class="comment">//请求体默认为undefined，当解析时才会填充，所以要使用body-parser</span></span><br><span class="line">app.use(express.urlencoded());</span><br><span class="line">app.use(express.json())</span><br><span class="line"><span class="comment">// 静态文件</span></span><br><span class="line">app.use(express.static(<span class="string">'public'</span>));</span><br><span class="line"><span class="comment">//跨域</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">5000</span>, <span class="built_in">console</span>.log(<span class="string">'Server is running on port 5000'</span>))</span><br><span class="line">app.use(<span class="string">'/student'</span>,studentRo)</span><br></pre></td></tr></table></figure><p><strong>使用ejs模板</strong><br><code>res.render(view[,locals][,callback])</code>   渲染view视图并将渲染好的html发送给客户端。locals是一个定义一些本地变量的对象，我们可以使用此参数传递数据<br><code>res.redirect([status,]path)</code>   重定向，状态码默认为302<br><code>app.set()</code>     可以使用此方法设置模板引擎等</p><p><strong>express提供了生成器</strong></p><p>全局安装express-generator<br><code>$ npm install express-generator -g</code><br>添加对ejs模板的支持<br><code>$ express -c</code><br><code>-f</code> 命令是强制在非空目录下创建</p><p>会生成所需要的各类文件和简单的功能</p><p><strong>cd到该目录下安装所有的依赖</strong><br><code>$ npm install</code></p><p>监听的端口默认为3000</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;express是一个基于node.js的web开发框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 首先要安装express插件并引入到js文件中，express是一个函数，所以要调用，调用后会返回一个实例（appplication），&lt;br&gt; 使用实例的一些方法来完
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>[原]Es6</title>
    <link href="http://yoursite.com/2019/01/02/%E5%8E%9F-Es6/"/>
    <id>http://yoursite.com/2019/01/02/原-Es6/</id>
    <published>2019-01-02T13:23:51.000Z</published>
    <updated>2019-01-07T13:51:40.645Z</updated>
    
    <content type="html"><![CDATA[<p><strong>let声明变量</strong></p><ol><li>声明不会提升</li><li>不能重复声明（当前作用域下不能有相同变量名），会报错</li><li>变量会捆绑在当前的语句块中，也就是说只在当前块级作用域下生效</li></ol><p><strong>const声明常量</strong></p><ol><li>声明不会提升</li><li>不能重复声明，会报错</li><li>在声明常量时，必须要赋值，否则会报错</li><li>一经赋值不可修改</li></ol><p><strong>函数参数的默认值</strong></p><p><code>function(color = ‘red’){}</code></p><p>red为color的默认值</p><p><strong>箭头函数</strong></p><p><code>var max = function(){}</code></p><p><code>var max = () =&gt; {}</code>    这行代码等价与上面的代码</p><p>当代码简洁时，可以把大括号去掉简写为一行</p><p>eg：<code>var max = (x,y) =&gt; x&gt;y?x:y;</code></p><p>=&gt; 后面的代码为return的值，但不能写return</p><p>如果函数的参数不止一个或没有，要用小括号包着，如果只有一个参数，可以省略括号。</p><p>箭头函数中没有this，如果使用this是指向window的</p><p><strong>剩余操作符 …</strong></p><p>我们可以在形参名前加上…来让它接受剩余的参数，当不确定实参个数时，这是个很好的选择。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b,…others</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//a=1,b=2,others就等于一个数组，里面包含所有剩下的实参，也就是[3,4,5,6,7]</span></span><br></pre></td></tr></table></figure><p><strong>展开操作符…</strong></p><p>我们可以在数组名前加上展开操作符，那么他就会显示数组中的各个元素</p><p>eg:  <code>let arr1 = [1,2,3]     console.log(…arr1)</code></p><p>控制台会打印1,2,3</p><p>我们也可以使用这个操作符来复制/合并数组</p><p>复制：let arr2 = […arr1]</p><p>合并：let arr2 = […arr1,4,5]</p><p><strong>模板字面量</strong></p><p>使用模板字面量来定义字符串，可以使用${}在字符串中插入内容，在括号中可写变量或表达式</p><p>并且在模板字面量中换行，会保留格式，换行和tab键都会放在字符串中</p><p><code>var str = `</code> `</p><p><strong>对象的属性简写</strong></p><p>当属性值和属性名相同时，可简写为一个变量名<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'李四'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">name</span><br><span class="line"><span class="comment">//这里的name值为李四</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>数组解构</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors=  [ <span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">let</span> [firstC,secC,thirdC] = colors;</span><br><span class="line"><span class="comment">// 上面的变量的值按顺序依次为数组中的颜色</span></span><br></pre></td></tr></table></figure></p><p>当为变量重新赋值时，只需将let 去掉即可。</p><p>为变量设置默认值，与函数形参默认值方法相同。</p><p><strong>嵌套数组解构</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors=  [ <span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,[<span class="string">'violet'</span>,<span class="string">'white'</span>]];</span><br><span class="line"><span class="keyword">let</span> [firstC,secC,thirdC,[,lastC]] = colors;</span><br></pre></td></tr></table></figure></p><p><strong>对象解构</strong><br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1= &#123;<span class="attr">name</span>:<span class="string">'lisi'</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age&#125; = obj1;</span><br></pre></td></tr></table></figure></p><p>与数组解构不同的是,上面这种方法只能当变量名和对象的属性名相同使可以使用，如果要为非同名的变量赋值，要写为以下的方式<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:myName,<span class="attr">age</span>:myAge&#125; = obj1;</span><br></pre></td></tr></table></figure></p><p>前面的是对象中的属性名，后面的为我们设置的变量名，相当于为变量指明要从哪里找值。</p><p>默认值：与函数形参的默认值的传值方式相同</p><p>为变量重新赋值：因为JavaScript不允许赋值操作符左边出现花括号，所以我们要将整个赋值语句用小括号包裹起来，将赋值语句变为一个表达式。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#123;<span class="attr">name</span>:myName,<span class="attr">age</span>:myAge&#125; = obj1;)</span><br></pre></td></tr></table></figure></p><p><strong>模块</strong></p><p>导出：<code>export {名称} /export 函数/变量</code></p><p>导出时重命名：<code>export{旧名字 as 新名字}</code></p><p>导出默认值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 名称</span><br><span class="line"><span class="keyword">export</span> &#123; 名称 <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 名称</span><br></pre></td></tr></table></figure></p><p>导入：<code>import {名称} from 文件路径</code></p><p>导入所有： <code>import *as 名称 from 文件路径</code> 用这个名称来使用，是一个对象，所有模块导出的东西都在里面</p><p>导入时重命名：<code>import {旧名字 as 新名字} from</code> 文件路径</p><p>导入默认值：<code>import 名称 from 文件路径</code> 默认值会被自动绑定到此名称上</p><p>一个模块的默认值只能有一个。</p><p>如果在一个js文件中导入模块，但并不使用它，可以再导出，起桥梁作用<br><code>export {名称} from 文件路径</code></p><p>如果一个文件中没有导入或导出，只是修改了一些全局方法，那么我们在另一个页面导入是，应该：<code>import 文件路径</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;let声明变量&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;声明不会提升&lt;/li&gt;
&lt;li&gt;不能重复声明（当前作用域下不能有相同变量名），会报错&lt;/li&gt;
&lt;li&gt;变量会捆绑在当前的语句块中，也就是说只在当前块级作用域下生效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Es6" scheme="http://yoursite.com/tags/Es6/"/>
    
  </entry>
  
  <entry>
    <title>[转]Evevt Loop 事件循环</title>
    <link href="http://yoursite.com/2019/01/02/%E8%BD%AC-Evevt-Loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <id>http://yoursite.com/2019/01/02/转-Evevt-Loop-事件循环/</id>
    <published>2019-01-02T12:26:40.000Z</published>
    <updated>2019-01-03T10:47:00.316Z</updated>
    
    <content type="html"><![CDATA[<p><strong>今天在看es6的promise的时候，看了一个很有意思的面试题，牵扯到了setTimeout的执行顺序，总结一下</strong></p><p><strong>贴一下面试题的链接</strong> Excuse me？这个前端面试在搞事！ - Liril的文章 - 知乎<a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25407758</a></p><p><img src="/images/EventLoop.png" alt="事件循环"></p><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p><p>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p><p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p><p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p><p><strong>setTimeout</strong></p><blockquote><p>如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立即执行，相反会把它放到队列中去，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。（setTimeout和setInterval经常有不守时的时候）。</p></blockquote><blockquote><p>setTimeout并不是真正的异步操作，只是把想执行的代码放到UI队列中，在未来执行</p></blockquote><p><strong>Es6中的Promise，里面的函数是直接执行的，比setTimeout执行的早</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;今天在看es6的promise的时候，看了一个很有意思的面试题，牵扯到了setTimeout的执行顺序，总结一下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贴一下面试题的链接&lt;/strong&gt; Excuse me？这个前端面试在搞事！ - Liril的
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[原]jQuery总结</title>
    <link href="http://yoursite.com/2018/12/21/%E5%8E%9F-jQuery%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/12/21/原-jQuery总结/</id>
    <published>2018-12-21T12:54:42.000Z</published>
    <updated>2019-01-03T10:43:26.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jQuery入口函数"><a href="#jQuery入口函数" class="headerlink" title="jQuery入口函数"></a><a id="jQuery_0"></a>jQuery入口函数</h2><p><code>$(document).ready(function(){})</code></p><p><code>$(function(){})</code></p><h2 id="js入口函数与jQ入口函数的区别"><a href="#js入口函数与jQ入口函数的区别" class="headerlink" title="js入口函数与jQ入口函数的区别"></a><a id="jsjQ_4"></a>js入口函数与jQ入口函数的区别</h2><p>js函数的入口函数比jq慢,因为js的入口函数会等待页面加载完成,并且外部资源也加载完成后才会执行,但jq</p><p>的入口函数等待页面加载完成后就会执行。</p><p>js入口函数只能执行一次,会产生覆盖,但jq的可以多次使用</p><h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a><a id="_9"></a>隐式迭代</h2><p>jQuery有隐式迭代的特性,会自动的遍历,设置操作时会给选择到所有的对象都设置上相同的值。在获取值时,如果选择的对象中有多个元素,就只会获取到第一个的值,因为隐式迭代会让jq认为所有的值都为相同的。</p><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a><a id="_12"></a>链式编程</h2><p>jq的方法都会返回一个对象,所以我们可以一直调用下去。但返回的如果不是当前对象,就不能链式下去。</p><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a><a id="_15"></a>选择器</h2><p><strong>基本选择器</strong></p><ol><li>ID选择器</li><li>类选择器</li><li>标签选择器</li><li>并列选择器    <code>$(&#39;p,span&#39;)</code></li><li>交集选择器    <code>$(&#39;p.box&#39;)</code></li></ol><p><strong>层次选择器</strong></p><ol><li>直接子级选择器</li><li>后代选择器</li><li>后面所有同级  $(“p~span”)</li><li>后面紧挨着的同级  $(“p+span”)</li></ol><p><strong>筛选选择器（方法）</strong>   ()里面也可以加选择器</p><p><code>.first()</code>                   第一个元素</p><p><code>.last()</code>                   最后一个</p><p><code>.children()</code>            相当于子级选择器</p><p><code>.find()</code>                   相当于后代选择器</p><p><code>.parent()</code>               父元素</p><p><code>.parents()</code>             祖先元素</p><p><code>.next()</code>                 下一个同级</p><p><code>.nextAll()</code>             下面所有的同级</p><p><code>.nextUntil()</code>            往下找,直到选择器为止不包括选择器（相当与一个区间）</p><p><code>.prev()</code>                 上一个</p><p><code></code>.prevAll() `             上面所有的同级</p><p><code>.prevUntil()</code>          往上找,直到选择器,不包含选择器</p><p><code>.siblings()</code>            除自身外所有的同级</p><p><code>.slice()</code>                  同数组方法</p><p><code>.filter()</code>                  选取满足选择器的元素</p><p><code>.not()</code>                    选取不满足选择器的元素</p><p><code>.has()</code>                   选取一个元素中有子元素满足此选择器</p><p><code>.is()</code>                      判断是否有此元素,如果一个有返回true,如果有多个,返回集合</p><p><code>.closest()</code>             从自身找距离自己最近的元素</p><p><code>.offsetParent()</code>     距离自己最近的定位祖先元素</p><p><code>.eq(index)</code>            选取指定下标的元素         .get(index)方法与此相同,但get()返回的是DOM对象,所以也可以用来将jq对</p><p>象转为DOM对象  ,$(dom对象)这种方法可以转为jq对象</p><p><strong>过滤选择器</strong></p><p><code>:first</code>              第一个</p><p><code>:last</code>               最后一个</p><p><code>:even</code>             偶数个</p><p><code>:odd</code>               奇数个</p><p><code>:gt(index)</code>        大于索引的</p><p><code>:lt(index)</code>         小于索引的</p><p><code>:contains()</code>     选取内容满足选择器的</p><p><code>:not</code>               不满足选择器的</p><p><code>:visible</code>          可见的元素</p><p><code>:hide</code>              隐藏的元素</p><p><code>:parent</code>           非空元素</p><p><code>:empty</code>         空元素</p><p><code>:has()</code>           选择包含有选择器的元素</p><p><code>:animate</code>        选择正在应用动画状态的元素</p><p><code>:target</code>           选择锚链接的目标位置</p><p><code>:button</code></p><p><code>:checked</code></p><p><code>:selecte</code></p><p><code>:disable</code></p><p><code>:enabled</code></p><p>所有css3的子元素选择器,属性选择器,这里就不过多写了(nth-child等)</p><p><strong>使用上下文获取元素</strong></p><p><code>$(“p”,&quot;#box&quot;)</code>   从#box下获取p元素</p><h2 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a><a id="_80"></a>操作样式</h2><p><strong>css()</strong></p><p>传一个参是获取样式值</p><p>传一个属性一个值是修改或添加</p><p>操作多个可以传对象</p><p><strong>操作class</strong></p><p><code>.addClass()</code>   添加类</p><p><code>.removeClass()</code> 移除类</p><p><code>.hasClass()</code>   判断是否有这个类</p><p><code>.toggleClass()</code>  切换类,如果有则删除,如果没有则加上</p><h2 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a><a id="_91"></a>操作属性</h2><p><strong>attr()</strong></p><p>与css的传参方式相同</p><p><code>removeAttr()</code>  删除属性</p><p><strong>prop()</strong></p><p>操作一些属性值为布尔值的属性,例如”<code>checked</code>,<code>disabled</code>等”</p><p><code>removeProp()</code>  删除属性</p><p><strong>data()</strong></p><p>操作自定义属性值</p><p><code>removeData()</code>   删除属性</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a><a id="_102"></a>动画</h2><p><code>show()</code>和<code>hide()</code>   显示和隐藏    第一个参数是动画执行时间,第二个回调函数</p><p>slideDown()<code>,</code>slideUp()<code>,</code>slideToggle()`    划入滑出和切换</p><p><code>fadeIn()</code>,<code>fadeOut()</code>,<code>fadeToggle()</code>       渐入,渐出和切换（改变透明度）</p><p><code>animated(property,执行时间,执行效果(swing/linear),回调函数)</code></p><p><strong>动画队列</strong></p><p>jq会把动画储存到动画队列中,动画会按照顺序执行,不会丢失。但如果多次快速触发动画,动画执行需要一定时间,当不触发动画时,动画依然会执行,一直等到动画队列结束,为了解决这个问题我们可以使用 <code>stop()</code>方法</p><p><code>stop()</code>方法要在动画前调用,当触发动画时,先停止之前动画,再执行动画效果。</p><p><code>stop()</code>的方法有两个参数,第一个为是否清除动画队列,第二个为是否跳到动画的最终效果,一般情况下我们不会使用这两个参数。</p><p><code>delay(延迟时间,[队列名称])</code>   推迟动画队列之后的项目</p><h2 id="节点操作（增删改复制）"><a href="#节点操作（增删改复制）" class="headerlink" title="节点操作（增删改复制）"></a><a id="_113"></a>节点操作（增删改复制）</h2><p>创建: <code>$()</code></p><p>添加: <code>append()</code>      添加到目标元素的最后面（作为子元素）    也可以把想要创建的元素直接写在括号中,会先创建后添加</p><p><code>appendTo()</code>   与上的不同在于:目标元素写在括号中</p><p><code>prepend ()</code>     添加到目标元素的子元素的最前面</p><p><code>prependTo()</code>   与 appendTo同理</p><p><code>after()</code>              添加到目标元素的下面（作为兄弟元素）</p><p><code>innerAfter()</code></p><p><code>before()</code>               添加到目标元素的上面（作为兄弟元素）</p><p><code>innerbefore()</code></p><p>替换: <code>replaceWith()</code>     把目标元素替换为括号中的元素</p><p><code>replaceAll()</code>         用括号中的元素替换目标元素</p><p>克隆: <code>clone(true)</code>    深复制,不仅复制元素本身及其子元素,还会复制其绑定的事件和数据</p><p><code>clone(true)</code>    浅复制,只复制元素本身及其子元素,不会复制事件及数据</p><p><code>clone(true,false)</code>   复制元素本身及其子元素,但只复制父元素的事件及数据,不复制子元素的事件及数据</p><p>只要第一个参数为false,则不管第二个参数是什么,都为false</p><p>删除: <code></code>empty()`     清空元素,但元素自身依旧存在。会解除绑定事件</p><p><code>html(&#39;&#39;)</code>       清空元素,但元素自身依旧存在。但不会清空被清空的元素身上绑定的事件,会造成内存泄露。</p><p><code>detach()</code>     删除元素,自身也会被删除。但此方法不会删除元素身上绑定的事件数据</p><p><code>remove()</code>    删除元素,自身也会被删除。这个方法会删除绑定的事件数据。</p><p>删除的这两个方法,都不会删除jq对象,都会返回被删除的元素。我们可以在需要的时候重新添加到页面中。</p><h2 id="事件的注册触发解绑"><a href="#事件的注册触发解绑" class="headerlink" title="事件的注册触发解绑"></a><a id="_135"></a>事件的注册触发解绑</h2><p>注册: <code>on(事件类型,[事件委托的子元素],[传递给事件处理函数的数据,一般使用event,data来回去],事件处理函数)</code></p><p>触发: <code>trigger(事件类型)</code><br><code>解绑:</code>off(事件类型)`</p><h2 id="特殊属性操作（属性值-高宽）"><a href="#特殊属性操作（属性值-高宽）" class="headerlink" title="特殊属性操作（属性值,高宽）"></a><a id="_140"></a>特殊属性操作（属性值,高宽）</h2><p>获取或修改表单中的值:<code>val()</code>   传值为修改</p><p>获取或修改标签中的值:<code>text()</code>   <code>html()</code>  与innerText和innerHTML相同</p><p><code>width()</code>   实际宽度width,返回一个数字,传值可修改</p><p><code>height()</code>   实际高度</p><p><code>innerWidth()</code>  width+padding</p><p><code>innerHeight()</code>   height+padding</p><p><code>outerwidth()</code>    width+padding+border</p><p><code>outerHeight()</code>   height+padding+border</p><p><code>outerwidth(true)</code>    width+padding+border+margin</p><p><code>outerHeight(true)</code>   height+padding+border+margin</p><p><code>scrollTop()</code>     被卷曲出去的高度</p><p><code>scrollLeft()</code>     被卷曲出去的宽度</p><p><code>offset()</code>     获取元素距离document的距离,返回一个对象,里面有top和left的值。如果设置传一个对象,设置之后会给元素加相对定位,改变位置。</p><p><code>position()</code>    获取元素距离有定位父元素的距离,只可获取不能修改</p><h2 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a><a id="_156"></a>操作集合</h2><p><code>add()</code>   合并集合,括号内可以是选择器,标签,DOM对象,jq对象</p><p><code>addBack()</code>   将过滤后的对象与上一个合并</p><p><code>contents()</code>   获取对象中每一个元素的内容（文本,注释和标签）</p><p><code>index()</code>     返回当前元素在所有兄弟元素里面的索引</p><p><code>end()</code>   返回到上一次的操作</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="$冲突"></a><a id="_163"></a>$冲突</h2><p>当jq拿到控制权时,可以使用<code>onConflict()</code>来释放控制权,如果没有控制权可以使用jQuery来代替$</p><h2 id="包裹元素"><a href="#包裹元素" class="headerlink" title="包裹元素"></a><a id="_166"></a>包裹元素</h2><p><code>wrap()</code>   使用一个元素包裹每一个被选择到的对象</p><p><code>wrapAll()</code>   使用一个元素包裹所有被选择到的元素</p><p><code>wrapInner()</code>   使用指定标签包裹元素中的内容</p><p><code>unwrap()</code>    删除包裹该元素的元素,也就是父元素,如果括号内传了选择器,如果不满足此选择器,则不会被删除</p><h2 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a><a id="_172"></a>工具方法</h2><p><code>$.each(function(索引,属性){})</code>   遍历</p><p><code>$.each(function(属性名,属性值){})</code>   遍历</p><p>遍历对象时形参为属性名和属性值,数组或jq对象时,形参为索引和属性</p><p><code>$.extend(true/false,obj1,obj2)</code>  将第二个及其以后的对象合并到第一个  第一个值为true是深合并,会合并对象中的对象,false则不会。如果对象中的属性名有相同的,后面的会覆盖前面的。如果属性值出现undefined,则会被忽略。</p><p>可以用来复制对象   $.extent({},obj1)</p><p><code>$.greg(数组,function(属性,索引){})</code>           从数组中过滤出满足条件的元素,返回值为布尔值</p><p><code>$.merge(arr1,arr2)`</code>    把第二个数组合并到第一个,这个方法只能有两个参数</p><p><code>$.inArray(要找的元素,去哪个数组找,从索引几开始找(默认0))</code>     属性是否在数组中,是则返回索引,不是返回-1</p><p><code>$.map(数组/对象,function(元素/属性值,索引/属性名){})</code>    用指定函数处理对象或数组中的每一个元素,返回值作为数组或对象中的元素,并把结果封装为新的数组或对象,如果返回null/undefined,则不会被添加到数组或对象中</p><p><code>$.makeArray()</code>     把一个类似数组（有集合,下标）的对象转为数组</p><p><code>$.isArray()</code>     判断是否为数组</p><p><code>$.isPlainObject()</code>  判断是否为一个对象</p><p><code>$.isEmptyObject()</code>   判断是否为空对象</p><p><code>$.type()</code>    检测数据类型   与typeof()类似</p><p><code>toArray()</code>   将JQ对象转为数组</p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><a id="AJAX_189"></a>AJAX</h2><p><code>$().load(url,与请求一同发送的查询字符串键/值对集合,回调函数)</code>   从服务器加载数据,并把返回的数据放置到指定元素中</p><p><code>$().getScript(url,回调函数)</code>   使用get方式获取js类型的数据</p><p><code>$().getJSON(url,回调函数)</code>    使用get方式获取quJSON类型的数据</p><p><code>$().get(url,回调函数,期望返回数据的类型)</code>  使用get方式获取指定类型的数据   能接受数据的类型有5种:html,text,JSON,js,xml</p><p><code>$().post(url,提交的数据,回调函数,期望返回数据的类型)</code>  使用post方式提交数据</p><p><code>$().ajax(url,各种设置)/ $().ajax(各种设置)</code>    设置:url,data数据,dataType数据类型,timeout超时时间,method提交方式,global :true/false是否触发全局ajax事件处理程序,success回调函数,error回调,complete回调,beforeSend回调</p><p><code></code>$().ajaxsetup()`  设置下面的ajax请求的默认值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jQuery入口函数&quot;&gt;&lt;a href=&quot;#jQuery入口函数&quot; class=&quot;headerlink&quot; title=&quot;jQuery入口函数&quot;&gt;&lt;/a&gt;&lt;a id=&quot;jQuery_0&quot;&gt;&lt;/a&gt;jQuery入口函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;$(document)
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>[原]jq要注意的点</title>
    <link href="http://yoursite.com/2018/12/08/%E5%8E%9F-jq%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/"/>
    <id>http://yoursite.com/2018/12/08/原-jq要注意的点/</id>
    <published>2018-12-08T12:09:21.000Z</published>
    <updated>2019-01-10T08:44:39.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查找下标"><a href="#查找下标" class="headerlink" title="查找下标"></a><a id="_0"></a>查找下标</h2><p>JQ对象查找指定下标的方法为：eq()</p><p>get()方法也是查找指定下标的，但返回的是dom元素</p><p>eg:今天写一个导航条绑定鼠标进入事件时播放指定音乐，因为JQ中没有封装audio 和 video 的方法，所以play的方法要绑定在DOM元素，这时如果要是使用eq的话就不对了。</p><p><s>一个报错</s></p><p>但是这时报错了<code>Uncaught (in promise) DOMException: play() failed because the user didn’t interact with the document first.</code></p><p>原来在Chrome 4月份更新了版本后，autoplay政策做了更改</p><p><strong>解决方法</strong>：打开 chrome://flags/#autoplay-policy</p><p>把Default修改为 No user gesture is required</p><h2 id="prop方法"><a href="#prop方法" class="headerlink" title="prop方法"></a><a id="prop_13"></a>prop方法</h2><p>prop()方法  是操作元素的属性</p><p>attr()方法是操作标签的属性</p><p>对于一些特殊的属性 eg: <code>checked, selected ,disabled</code> 这些值为布尔值的属性，无法使用attr方法设置，因为JQ对于未设置的这些特殊属性会返回undefined，所以要用prop方法</p><p>用法和attr相同  eg : <code>prop(&#39;checked&#39;,&#39;true&#39;)</code></p><h2 id="动画队列"><a href="#动画队列" class="headerlink" title="动画队列"></a><a id="_20"></a>动画队列</h2><p>JQ中会把动画放在一个动画队列中。如果调用多个动画，它也会按照顺序挨个执行，不会覆盖，也会把动画保存好，但同时不好的地方也出现了。如果有一个鼠标进入触发动画的函数，用户多次触发并速度很快，那么鼠标离开后 ，它仍然会执行，直到动画队列中的动画执行完。</p><p><strong>解决方法</strong>：stop()方法    停止正在执行的动画</p><p>在动画方法前调用此方法就可以解决动画队列的问题。</p><p><code>stop(clearQueue,jumpToEnd)</code> 参数值都为布尔型</p><p>clearQueue : 是否清除动画队列</p><p>jumpToEnd : 是否跳转到当前动画的最终效果</p><p>不传参默认都为 false。</p><h2 id="index-方法"><a href="#index-方法" class="headerlink" title="index()方法"></a><a id="index_30"></a>index()方法</h2><p>JQ中的index()方法会返回当前元素在所有兄弟元素中的索引<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=""&gt;&lt;/a&gt;&lt;/li&gt;</span><br><span class="line"><span class="comment">//如果给a标签使用index()方法就只会显示0,要对li标签使用此方法</span></span><br></pre></td></tr></table></figure></p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a><a id="_39"></a>删除节点</h2><p>remove()和detach()都是删除节点。</p><p>区别：remove方法会删除自身元素及其内容，也会删除事件监听和数据。</p><p>detach方法只删除元素本身及其内容。</p><p>两种方法都会保留 jQuery 对象中的匹配的元素，返回的是被选择的这个元素，所以可以在将来再使用这些匹配的元素。</p><p>所以在进行大规模的增删改时我们可以先把一个元素提取出来，在此元素上面进行操作，在重新添加到页面中，就减少了对DOM的操作的修改，从而减少了页面重绘，但是这种时候最好使用detach()方法，因为此方法不会删除自身的事件及数据。</p><h2 id="data方法"><a href="#data方法" class="headerlink" title="data方法"></a><a id="data_48"></a>data方法</h2><p>从1.4.3开始我们通过自定义属性给元素绑定数据，也会被自动的添加到jQuery的数据对象中，因此我们也可以通过data方法操作。</p><p>获取：.data(属性名)   不传参是获取所有的</p><p>设置：data(属性名：属性值)</p><p>删除：removeData(属性名)</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a><a id="_55"></a>事件委托</h2><p>我们可以使用on方式来绑定简单的事件</p><p>eg：<code>$(&#39;#box&#39;).on(&#39;click&#39;,function(){})</code></p><p>但是如果我们的页面中动态添加的元素不会被绑定到此事件，所以我们可以使用事件委托的方式；</p><p><strong>语法</strong>：父元素.on(事件类型,事件委托的子元素，传递给处理函数的数据，事件处理函数)</p><p><strong>原理</strong>：通过给父元素注册事件委托，但子元素身上其实是没有事件的。利用了事件冒泡，触发父元素事件，把事件分发给了子元素，最终还是由子元素执行的。支持动态创建添加的元素。</p><p><strong>传递的数据</strong>：传递给处理函数的数据，事件触发时可以通过event.data来使用</p><h2 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a><a id="_64"></a>克隆节点</h2><p><code>clone(true)</code>    深复制，复制自身及其子元素，并复制其事件和数据</p><p><code>clone(false)</code>   浅复制，复制自身及其子元素，不复制其事件和数据</p><p><code>clone(true，false)</code>   复制自身及其子元素，并复制父元素的事件和数据但不会复制子元素的事件和数据</p><p>只要第一个参数为false，则无论第二个参数无论设置成什么，都为false</p><h2 id="冲突"><a href="#冲突" class="headerlink" title="$冲突"></a><a id="_71"></a>$冲突</h2><p>如果我们一个页面引入多个框架，可能会导致<code>$</code>冲突的问题，默认后面会覆盖前面的，那么在jQuery拿到控制权的前提下，jQuery给我们提供了释放<code>$</code>控制权的方法。</p><p><code>$.noConflict()</code>  我们可以使用一个变量来接受一下，用来代替<code>$</code></p><p>在没有控制权时也可以使用jQuery来代替<code>$</code></p><h2 id="制作jQuery插件"><a href="#制作jQuery插件" class="headerlink" title="制作jQuery插件"></a><a id="jQuery_77"></a>制作jQuery插件</h2><p>我们可以通过给<code>$.fn</code>添加方法开扩展jQuery对象</p><p><code>$.fn</code>等价于<code>jQuery.prototype`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;查找下标&quot;&gt;&lt;a href=&quot;#查找下标&quot; class=&quot;headerlink&quot; title=&quot;查找下标&quot;&gt;&lt;/a&gt;&lt;a id=&quot;_0&quot;&gt;&lt;/a&gt;查找下标&lt;/h2&gt;&lt;p&gt;JQ对象查找指定下标的方法为：eq()&lt;/p&gt;
&lt;p&gt;get()方法也是查找指定下标的，但返回
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>[原]关于属性</title>
    <link href="http://yoursite.com/2018/12/04/%E5%8E%9F-%E5%85%B3%E4%BA%8E%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/12/04/原-关于属性/</id>
    <published>2018-12-04T13:19:42.000Z</published>
    <updated>2019-01-03T10:49:59.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象的增删改查"><a href="#对象的增删改查" class="headerlink" title="对象的增删改查"></a><a id="_0"></a>对象的增删改查</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字面量的形式实例化 Object 对象</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    myName: <span class="string">'周正国'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">添加属性</span><br><span class="line">obj1.age = <span class="number">20</span>;</span><br><span class="line">obj1[<span class="string">'gender'</span>] = <span class="string">'男'</span>;</span><br><span class="line"></span><br><span class="line">修改属性的值</span><br><span class="line">obj1.age += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">访问属性</span><br><span class="line">obj1[<span class="string">'myName'</span>]</span><br><span class="line">obj1.myName</span><br><span class="line"></span><br><span class="line">删除属性</span><br><span class="line"><span class="keyword">delete</span> obj1.age;</span><br></pre></td></tr></table></figure><h2 id="遍历对象中的属性"><a href="#遍历对象中的属性" class="headerlink" title="遍历对象中的属性"></a><a id="_22"></a>遍历对象中的属性</h2><ol><li>for in 遍历</li><li>Object.keys(要遍历的对象)<br>构造函数.方法=function(){}  可以不用实例化对象就可以通过<strong>构造函数.方法（）</strong>来调用，如上。</li></ol><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a><a id="_28"></a>对象属性</h2><ol><li>数据属性      保存的是数据      <strong>属性名：属性值</strong>的方式</li><li>访问器属性   通常用于隐藏数据     用get，set 方法来获取或者设置属性</li></ol><h2 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a><a id="_33"></a>对象的方法</h2><p>  <strong>判断一个属性是否在对象中</strong></p><ol><li>in 操作符                   属性名 in 对象名   hasOwnProperty()</li><li><p>对象名.hasOwnProperty（属性名）</p><p>区别：2只会在对象的自有属性列表中查找，而1不仅会在自有属性列表下查找，还会沿着原型链查找。</p><p><strong>判断某个属性是否可枚举</strong></p></li></ol><p><code>对象.propertyIsEnumerable()</code></p><p>  <strong>判断一个对象是否是另一个对象的原型</strong></p><p><code>原型.isPropertyOf(对象)</code></p><h2 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a><a id="_51"></a>属性的特性</h2><p>  <em><strong>获取属性的特性</strong></em></p><p>我们可以通过以下方式获取一个或多个属性的特性</p><ol><li>Object.getOwnPropertyDescriptor(对象名,要获取的属性名)          获取对象中该属性的特性</li><li><p>Object.getOwnPropertyDescriptors（对象名）   获取对象中所有的属性的特性</p><p>如下图代码打印一下它们获取到的特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> student=&#123;</span><br><span class="line">       studentName:<span class="string">"大雨"</span>,</span><br><span class="line">       age:<span class="number">20</span>,</span><br><span class="line">       play:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"打豆豆"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">var</span> stu1=<span class="built_in">Object</span>.getOwnPropertyDescriptor(student,<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu2=<span class="built_in">Object</span>.getOwnPropertyDescriptors(student);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(stu1);</span><br><span class="line">   <span class="built_in">console</span>.log(stu2);</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/jietu01.png" alt="截图"></p><p>可以看到得到的是一个对象，那么可以看到它的特性有四个</p><ul><li>configurable       是否可配置</li><li>enumerable        是否可枚举</li><li>value                  属性值</li><li><p>writable              是否可写<br>当然它们默认都是 true 。我们也可以去控制这些特性。</p><p><em><strong>控制属性的特性</strong></em></p></li></ul><ol><li>Object.defineProperty(对象名，属性，{修改特性的值 })    —–&gt; 控制一个属性的值</li><li>Object.defineProperties(对象名，{属性名：{修改特性的值},属性名：{修改特性的值}})   —–&gt; 控制一个属性的值<pre><code class="javascript"><span class="built_in">Object</span>.defineProperty(student,<span class="string">"age"</span>,{        value:<span class="number">18</span>,        configurable:<span class="literal">false</span>,        enumerable:<span class="literal">false</span>,        writable:<span class="literal">false</span>    })        <span class="built_in">Object</span>.defineProperties(student,{            gender:{            value:<span class="string">"女"</span>,            configurable:<span class="literal">true</span>,            enumerable:<span class="literal">false</span>,            writable:<span class="literal">false</span>            },            num:{            value:<span class="number">01</span>,            configurable:<span class="literal">false</span>,            enumerable:<span class="literal">false</span>,            writable:<span class="literal">true</span>            }        })        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(student,<span class="string">"age"</span>))        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptors(student)</code></pre></li></ol><p><img src="/images/jietu02.png" alt="在这里插入图片描述"></p><p>所以我们也可以利用这种方式添加属性或者修改属性值，同时设置属性的特性</p><h2 id="禁止对象扩展"><a href="#禁止对象扩展" class="headerlink" title="禁止对象扩展"></a><a id="_118"></a>禁止对象扩展</h2><p>查询对象是否可被扩展     Object.isExtensible(要查询的对象名)       默认都为true。</p><p>禁止对象扩展     Object.preventExtensions(要禁止的对象名)</p><p>禁止对象扩展的特性：不可向对象中添加新的属性</p><h2 id="对象封印"><a href="#对象封印" class="headerlink" title="对象封印"></a><a id="_123"></a>对象封印</h2><p>判断对象是否被封印     Object.isSealed(要查询的对象名)</p><p>封印对象       Object.seal(要封印的对象名)</p><p>对象被封印后的特性：不可删除属性，不可添加新属性，可以修改属性值。</p><p>所有被封印对象的属性的特性都被设置了：configurable: false</p><h2 id="冻结对象"><a href="#冻结对象" class="headerlink" title="冻结对象"></a><a id="_128"></a>冻结对象</h2><p>判断对象是否被冻结      Object.isFrozen(要查询的对象名)</p><p>封印对象       Object.freeze(要封印的对象名)</p><p>对象被封印后的特性：不可删除属性，不可添加新属性，不可修改属性值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象的增删改查&quot;&gt;&lt;a href=&quot;#对象的增删改查&quot; class=&quot;headerlink&quot; title=&quot;对象的增删改查&quot;&gt;&lt;/a&gt;&lt;a id=&quot;_0&quot;&gt;&lt;/a&gt;对象的增删改查&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[原]继承</title>
    <link href="http://yoursite.com/2018/12/01/%E5%8E%9F-%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2018/12/01/原-继承/</id>
    <published>2018-12-01T11:08:10.000Z</published>
    <updated>2019-01-10T08:45:49.597Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_0"></a>定义</h2><p>面向对象的特性：封装，继承，多态。</p><p>继承是类与类之间的关系，在面向对象的语言中是为了多态服务的。而js不是一门面向对象的语言，没有类的概念，但是我们可以模拟面向对象，模拟继承。继承是一种父类级别与子类级别的关系。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><a id="_4"></a>方法</h2><p>1、原型继承—-&gt;改变原型的指向</p><p><em>原型的作用是数据共享，目的是为了节省内存空间，那么在这我们可以知道原型的另一个作用：继承。所以，继承的作用也是为了节省内存空间。</em></p><p>缺陷：因为在改变原型指向的同时初始化了属性，那么继承的属性值都是相同的，只能调用对象的属性重新赋值，这样就</p><p>太过于浪费时间了。</p><p>2、借用构造函数继承 —&gt; call()方法</p><p>缺陷：不会继承原型中添加的方法</p><p>3、组合继承 —&gt; 原型继承+借用构造函数继承            改变指向时不初始化属性，既解决了属性问题又解决了方法问题。</p><p>4、拷贝继承 —&gt; 把需要共享的属性及方法，通过for in遍历的方式复制到另一个属性中</p><p><strong>补充</strong></p><p>5、对象继承 —&gt; 可以使用这种方法创建对象，同时指定新对象的原型指向，并且可以设置属性的特性，较为灵活。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.creat(要指向的原型，&#123;</span><br><span class="line">         属性值：&#123;</span><br><span class="line">         value：值，</span><br><span class="line">         enumerable:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">         configurable:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">         writable:<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;&lt;a id=&quot;_0&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;面向对象的特性：封装，继承，多态。&lt;/p&gt;
&lt;p&gt;继承是类与类之间的关系，在面向对象的语言中是为了多态服务的。
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[原]原型和原型链</title>
    <link href="http://yoursite.com/2018/12/01/%E5%8E%9F-%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2018/12/01/原-原型和原型链/</id>
    <published>2018-12-01T01:02:01.000Z</published>
    <updated>2019-01-07T13:51:34.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_0"></a>定义</h2><p>实例对象中有<strong>proto</strong>这个属性，叫原型，也就是一个对象。这个属性是给浏览器使用的，不是标准的属性。</p><p>构造函数有prototype这个属性，也是原型。这个属性是给程序员使用的，是标准的属性。—&gt;它们都可以叫原型对象。</p><h2 id="获取对象的原型的值"><a href="#获取对象的原型的值" class="headerlink" title="获取对象的原型的值"></a><a id="_5"></a>获取对象的原型的值</h2><ol><li>实例对象.<strong>proto</strong></li><li>构造函数.prototype</li><li>Object.getPrototypeof(对象名)</li></ol><h2 id="实例化对象，构造函数和原型对象三者的关系"><a href="#实例化对象，构造函数和原型对象三者的关系" class="headerlink" title="实例化对象，构造函数和原型对象三者的关系"></a><a id="_11"></a>实例化对象，构造函数和原型对象三者的关系</h2><p>1、构造函数可以实例化对象。实例对象是通过构造函数创建的，创建的过程叫实例化，如果传参，就是对属性进行初始化。</p><p>2、构造函数中有一个prototype这个属性，是构造函数的原型对象。</p><p>3、原型对象中有一个构造器（constructor），构造器指向的是它所在的原型对象所在的构造函数。</p><p>4、实例对象的原型对象指向的是它所在的构造函数的原型对象。实例化对象.<strong>proto</strong>==构造函数prototype —-&gt;true。</p><p>5、构造函数的原型对象中的方法可以直接被实例对象直接访问。</p><p>6、原型对象中的方法可以互相调用。</p><p>7、实例对象所使用的方法或属性，首先在实例中查找，找到了直接使用，如果找不到则去实例对象的原型对（<strong>proto</strong>）所指向的原型对象（prototype）中找，找到了使用，找不多就报错。</p><h2 id="原型的指向是可以改变的"><a href="#原型的指向是可以改变的" class="headerlink" title="原型的指向是可以改变的"></a><a id="_21"></a>原型的指向是可以改变的</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.eat=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Animal的吃"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.play=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Person的玩"</span>)</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> sheep=<span class="keyword">new</span> Animal();</span><br><span class="line">sheep.eat（）</span><br></pre></td></tr></table></figure><p>此时代码会报错，因为把Animal的原型指向了Person的原型，那么sheep将不能调用Animal原型里面的方法。</p><p>因为实例对象的原型（<em>proto</em>）指向的是该对象所在的构造函数的原型对象（prototype），构造函数的原型对象（prototype）如果改变了，实例对象（<em>proto</em>）的指向也会改变。</p><p>同时<em>Animal也继承了Person</em>。</p><p>那么如果又想改变指向，又想访问到方法，<strong>解决方法：在原型改变后再添加方法</strong></p><h2 id="原型的简单写法"><a href="#原型的简单写法" class="headerlink" title="原型的简单写法"></a><a id="_44"></a>原型的简单写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">构造函数.prototype=&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要手动修改构造器的指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constructor</span>:构造函数；</span><br><span class="line"></span><br><span class="line">属性：属性值；</span><br><span class="line"></span><br><span class="line">方法：function（）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这样的写法也是改变了原型指向，让原型指向了一个对象，所以，如果先在原型上添加了一个方法，在使用此方式添加属性和方法，那么在原型上添加的方法将不会被访问到。解决方法：同上</strong></p><h2 id="原型链定义"><a href="#原型链定义" class="headerlink" title="原型链定义"></a><a id="_56"></a>原型链定义</h2><p>原型链是实例对象和原型对象通过原型（<strong>proto</strong>）来联系的一种关系。是通过原型继承，形成了一个链条。</p><h2 id="原型链的最终指向"><a href="#原型链的最终指向" class="headerlink" title="原型链的最终指向"></a><a id="_59"></a>原型链的最终指向</h2><p>实例对象.<strong>proto</strong>—&gt;构造函数.prototype</p><p>实例对象.<strong>proto</strong>.<strong>proto</strong>—&gt;构造函数.prototype.<strong>proto</strong></p><p>构造函数.prototype.<strong>proto</strong>—&gt;object.prototype</p><p>object.prototype.<strong>proto</strong>—&gt;null</p><p>所以object.prototype是顶层</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;&lt;a id=&quot;_0&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;实例对象中有&lt;strong&gt;proto&lt;/strong&gt;这个属性，叫原型，也就是一个对象。这个属性是给浏览器使
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[原]flex box布局</title>
    <link href="http://yoursite.com/2018/11/26/%E5%8E%9F-flex-box%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/11/26/原-flex-box布局/</id>
    <published>2018-11-26T12:31:14.000Z</published>
    <updated>2019-01-03T10:42:53.602Z</updated>
    
    <content type="html"><![CDATA[<p>给父级元素设置display：flex会使之转成弹性盒模型，为我们提供了简单方便的设置盒子水平垂直居中的方法。</p><ol><li><p>设置主轴（水平）方向居中</p><p>justify-content :        flex-start  （默认值）主轴起始点位置对齐（水平方向左对齐）</p><p>flex-end      主轴的结束位置（水平方向右对齐）</p><p>center          居中对齐</p><p>space-between    两端对齐，项目之间的间隙相等</p><p>space-around    项目之间的间隙比项目到边框的间隙大一倍，与 space-between   的区别在于此方式两端会有一定的空隙，而 space-between 项目是紧挨着边框的</p><p><img src="/images/justify-content.png" alt="justify-content 对齐图解"></p></li><li><p>设置交叉轴（垂直）上的对齐方式</p><p>align-items：    stretch （默认值）  当子元素盒子没有设置高度或设置为auto时，垂直方向自适应，也就是高度会填充满父元素</p><p>flex-start      交叉轴起始点位置对齐</p><p>flex-end       交叉轴的终点对齐</p><p>center          交叉轴的中点对齐</p><p>baseline       基于第一行文字的基线对齐</p><p><img src="/images/align-items.png" alt="align-items对齐图解"></p></li><li><p>多行沿交叉轴对齐（多行轴线的对齐方式）<strong>如果只有一根轴线，不起作用</strong></p><p>align-content :        flex-start      与交叉轴的起点对齐</p><p>flex-end       交叉轴的终点对齐</p><p>center          交叉轴的中间对齐</p><p>space-between    交叉轴两端对齐，均匀分布</p><p>space-around        多行中行与行之间的上下距离是最上或最下一行距离上下边框距离的一倍，也就是相当于上图倒过来的效果</p></li></ol><p>那么如果想设置一个盒子垂直水平居中的话就可以给他的父级元素设置： display：flex</p><p>justify-context : center</p><p>align-item : center</p><p>关于子容器的操作方式目前只接触了  设置子容器空间的分配方法flex，收藏了关于这些的一些文章</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给父级元素设置display：flex会使之转成弹性盒模型，为我们提供了简单方便的设置盒子水平垂直居中的方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置主轴（水平）方向居中&lt;/p&gt;
&lt;p&gt;justify-content :        flex-start  （默认值）主轴起
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>[原]自定义构造器函数</title>
    <link href="http://yoursite.com/2018/11/26/%E5%8E%9F-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/11/26/原-自定义构造器函数/</id>
    <published>2018-11-26T04:30:00.000Z</published>
    <updated>2019-01-10T08:46:00.696Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结笔记"><a href="#总结笔记" class="headerlink" title="总结笔记"></a><a id="_0"></a>总结笔记</h2><p>自定义构造器函数相当于一个模板，需要的时候去引用它，函数内没有new和返回值，this是当前对象。</p><p>通过new的方式开创建对象，也就是实例化对象，同时对属性进行初始化</p><p><em>实例化对象的构造器（constructor）是指向构造函数的。所以，实例对象是通过构造器函数来创建设的，这个创建的过程教实例化</em>。</p><p>判断这个对象是否属于这种数据类型的方式有两种：</p><p>1、通过构造器方式————&gt;实例对象.constructor==构造函数</p><p>2、<strong>instanceof 方式</strong>（尽可能使用这种方式）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    consolo.log(<span class="string">"吃"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> per=<span class="keyword">new</span> Person(<span class="string">"li"</span> ,<span class="number">18</span>)</span><br><span class="line">per.eat()</span><br></pre></td></tr></table></figure></p><p>上面的eat（）是一个方法，如果多次创建对象，那么创建的对象中的eat方法不是同一个，所以就会占用大量内存空间，</p><p>所以要使用原型。</p><p>那么原型的作用之一就是  —&gt;  <strong>数据共享，节省内存空间</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总结笔记&quot;&gt;&lt;a href=&quot;#总结笔记&quot; class=&quot;headerlink&quot; title=&quot;总结笔记&quot;&gt;&lt;/a&gt;&lt;a id=&quot;_0&quot;&gt;&lt;/a&gt;总结笔记&lt;/h2&gt;&lt;p&gt;自定义构造器函数相当于一个模板，需要的时候去引用它，函数内没有new和返回值，this是当前对
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[转]全局捕获</title>
    <link href="http://yoursite.com/2018/11/15/%E8%BD%AC-%E5%85%A8%E5%B1%80%E6%8D%95%E8%8E%B7-1/"/>
    <id>http://yoursite.com/2018/11/15/转-全局捕获-1/</id>
    <published>2018-11-15T01:15:18.000Z</published>
    <updated>2019-01-07T13:34:29.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局捕获的理解"><a href="#全局捕获的理解" class="headerlink" title="全局捕获的理解"></a><a id="_0"></a>全局捕获的理解</h2><p>全局捕获只支持鼠标事件，不支持键盘事件。</p><p>全局捕获： 全局（包含浏览器外）出现一个鼠标事件，会被设置全局捕获的对象捕获，如果此对象正好有对应的事件函数，</p><p>那么会被触发，而最初的发起事件的元素就不会执行它的事件函数了，通俗点说就是事件被掠走了。</p><p>全局捕获只能执行一次捕获的事件，如果持续捕获可能会出现问题，可以想象下：</p><p>如果全局捕获点击事件，鼠标无论点击哪里都会执行那段代码，那么连最基本的关闭浏览器窗口都不行了。</p><p>如果持续捕获，必须有取消全局捕获。</p><hr><p>作者：jerny2017</p><p>来源：CSDN</p><p>原文：<a href="https://blog.csdn.net/jerny2017/article/details/80282502" target="_blank" rel="noopener">https://blog.csdn.net/jerny2017/article/details/80282502</a></p><p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理。这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰</p><p>另外，还有一个很重 要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。</p><p>所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事 件已经不再发给这个圆点对象了。</p><p>web开发和windows开发最大的区别就是windows开发是有状态的，而web开发是无状态的，在windows中，一切操作都可以由程序来控制 ，除非强制执行ctrl+alt+del；但web操作就不一样了，即使执行很重要的操作，用户一点击浏览器关闭按钮，就将前面操作成果化为乌有.尽管可以在onunload事件中加些代码，让用户可以选择是否退出，但不能从根本上解决问题!</p><p>前几天，从网上看到setCapture方法，了解了一下，大体是这样的意思，当在IE文档某个区域中使用了这个方法，并且写了onclick或者 onmouse***等有关的鼠标事件方法，那么它就会监视相应的鼠标操作，即使你的鼠标移出了IE，它也一样能捕获到.如果你在某div中的 onclick事件中写了一个alert命令，这时，你点击的关闭按钮，它也一样会弹出alert窗口.releaseCapture与 setCapture方法相反，释放鼠标监控.</p><p>利用这个特性，我们可以延缓IE的关闭窗口等破坏性操作，将一些重要的操作能够在破坏性操作执行之前得到处理.</p><p>有一点遗憾:setCapture和releaseCapture 不支持键盘事件.只对onmousedown， onmouseup， onmousemove， onclick， ondblclick， onmouseover， onmouseout这样的鼠标事件起作用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局捕获的理解&quot;&gt;&lt;a href=&quot;#全局捕获的理解&quot; class=&quot;headerlink&quot; title=&quot;全局捕获的理解&quot;&gt;&lt;/a&gt;&lt;a id=&quot;_0&quot;&gt;&lt;/a&gt;全局捕获的理解&lt;/h2&gt;&lt;p&gt;全局捕获只支持鼠标事件，不支持键盘事件。&lt;/p&gt;
&lt;p&gt;全局捕获： 全
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>[转]call（），apply（）和bind（）</title>
    <link href="http://yoursite.com/2018/11/14/%E8%BD%AC-call%EF%BC%88%EF%BC%89%EF%BC%8Capply%EF%BC%88%EF%BC%89%E5%92%8Cbind%EF%BC%88%EF%BC%89-1/"/>
    <id>http://yoursite.com/2018/11/14/转-call（），apply（）和bind（）-1/</id>
    <published>2018-11-14T14:07:44.000Z</published>
    <updated>2019-01-10T08:46:13.393Z</updated>
    
    <content type="html"><![CDATA[<p>今天对于call方法和apply方法有些懵，所以去看了些别人的总结，感觉有了点概念，把一些大佬写的东西中自己感觉易懂的解释和经典的案例记录一下。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_5"></a>定义</h2><p>call方法:</p><p>语法：call([thisObj][,实参])</p><p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</p><p>说明：</p><p>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。（ 第一个借用别人的函数，第二个借用别人的上下文环境。） 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p><p>用括号的第一个参数来代替this的指向</p><p>call（） 就是用来让括号里的对象 来集成括号外的函数的属性！可以称之为继承！</p><p>apply方法：</p><p>语法：apply([thisObj[,argArray]])</p><p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</p><p>说明：</p><p>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。</p><p>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数</p><p>作用相同，只是书写格式不同</p><h2 id="call方法案例"><a href="#call方法案例" class="headerlink" title="call方法案例"></a><a id="call_24"></a>call方法案例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    alert(a-b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(sub,<span class="number">3</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>个人理解call和apply的作用就是切换函数的对象上下文。</p><p>这个例子中的意思就是用 add 来替换 sub“，应该是将add执行的上下文由window切换为sub，即this指向是从window变为sub，仅此而已，并非add替换sub。这个例子很难说明什么。</p><p>其实就是call方法前面的东西(add)都交给后面(sub)了，就像兄弟，接过这把枪。</p><p><code>add.call(sub,3,1) // sub 已经接过了add方法</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"Animal"</span>;    </span><br><span class="line"><span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">alert(<span class="keyword">this</span>.name);    </span><br><span class="line"> &#125;    </span><br><span class="line">&#125;     </span><br><span class="line">.function Cat()&#123;    </span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"Cat"</span>;    </span><br><span class="line">&#125;      </span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();    </span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入结果为"Cat"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//animal.showName.call](//animal.showName.call)(cat,",");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//animal.showName.apply](//animal.showName.apply)(cat,[]);</span></span><br></pre></td></tr></table></figure></p><p>call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name应该是 Cat。</p><p>关于javascript中call和apply函数的应用</p><p>关于类的初始化应用如下：<br>复制代码 代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.Init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); </span><br><span class="line">&#125;; </span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">first: <span class="literal">null</span>, </span><br><span class="line">last: <span class="literal">null</span>, </span><br><span class="line">Init: <span class="function"><span class="keyword">function</span>(<span class="params">first, last</span>) </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.first = first; </span><br><span class="line"><span class="keyword">this</span>.last = last; </span><br><span class="line">&#125;, </span><br><span class="line">fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.first + <span class="string">' '</span> + <span class="keyword">this</span>.last; </span><br><span class="line">&#125;, </span><br><span class="line">fullNameReversed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.last + <span class="string">', '</span> + <span class="keyword">this</span>.first; </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Person2(<span class="string">'creese'</span>, <span class="string">'yang'</span>); </span><br><span class="line">alert(s.fullName()); </span><br><span class="line">alert(s.fullNameReversed());</span><br></pre></td></tr></table></figure></p><p>call和apply函数可以赋值函数内容（带匿名参数；但不触发）</p><p> call和apply函数关于函数绑定参数应用如下：</p><p>复制代码 代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.Bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">var</span> __m = <span class="keyword">this</span>,</span><br><span class="line">    object = <span class="built_in">arguments</span>[<span class="number">0</span>],</span><br><span class="line">    args = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>； i &amp;lt; <span class="built_in">arguments</span>.length； i++)&#123; </span><br><span class="line">args.push(<span class="built_in">arguments</span>[i]); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line"><span class="keyword">return</span> __m.apply(object, args); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>call和apply函数功能是一样的；就是参数格式不同；fun.call(obj， arguments)；apply的arguments是数组形式；call则是单数形式。</p><h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a><a id="bind_146"></a>bind()方法</h2><p>bind与前两个不同，前两个是改变this的指向，而bind是绑定this的指向，返回的是一个this指向为你所绑定的一个新函数，而原本的函数并没有改变。并且，call和apply改变this指向时会自动调用此函数，但bind不会，需要手动去调用并传参。如果在绑定this指向时传参，那参数的值就不能再改变。</p><p><strong>语法</strong></p><p>bind（this指向）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天对于call方法和apply方法有些懵，所以去看了些别人的总结，感觉有了点概念，把一些大佬写的东西中自己感觉易懂的解释和经典的案例记录一下。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
</feed>
