<body>
    <script>
        var url = "";
        var root = window.location.origin + '/';
        var index = window.location.href.indexOf(root);
        if (index == -1) {
            url = window.location.origin + "/#" + window.location.pathname;
        } else {
            url = root + "#/" + window.location.href.substring(root.length);
        }
        window.location.href = url.substring(0, url.length - 1);
    </script>
</body>
<meta charset="utf-8">
<h3>[转]Evevt Loop 事件循环</h3>
<br>
<p></p><p><strong>今天在看es6的promise的时候，看了一个很有意思的面试题，牵扯到了setTimeout的执行顺序，总结一下</strong></p>
<p><strong>贴一下面试题的链接</strong> Excuse me？这个前端面试在搞事！ - Liril的文章 - 知乎<a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25407758</a></p>
<p><img src="/images/EventLoop.png" alt="事件循环"></p>
<p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。</p>
<p>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</p>
<p>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</p>
<p>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p>
<p><strong>setTimeout</strong></p>
<blockquote>
<p>如果以0毫秒的超时时间来调用setTimeout(),那么指定的函数不会立即执行，相反会把它放到队列中去，等到前面处于等待状态的事件处理程序全部执行完成后，再“立即”调用它。（setTimeout和setInterval经常有不守时的时候）。</p>
</blockquote>
<blockquote>
<p>setTimeout并不是真正的异步操作，只是把想执行的代码放到UI队列中，在未来执行</p>
</blockquote>
<p><strong>Es6中的Promise，里面的函数是直接执行的，比setTimeout执行的早</strong></p>
<p></p>