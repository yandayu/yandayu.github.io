<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="yan"><meta name="keywords" content="闫大雨，前端，博客"><meta name="description" content="个人博客"><link rel="alternative" href="/atom.xml" title="闫大雨的博客" type="application/atom+xml"><link rel="icon" href="/img/h2.gif"><title>[转]call（），apply（）和bind（） - 闫大雨的博客</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">闫大雨的博客</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-11-14T09:07:44.000Z">十一月 14, 2018</time><h1 class="post__title"><a href="/2018/11/14/转-call（），apply（）和bind（）/">[转]call（），apply（）和bind（）</a></h1><div class="post__main echo"><p>今天对于call方法和apply方法有些懵，所以去看了些别人的总结，感觉有了点概念，把一些大佬写的东西中自己感觉易懂的解释和经典的案例记录一下。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_5"></a>定义</h2><p>call方法:</p>
<p>语法：call([thisObj[,arg1[, arg2[,   [,.argN]]]]])</p>
<p>定义：调用一个对象的一个方法，以另一个对象替换当前对象。</p>
<p>说明：</p>
<p>call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。（ 第一个借用别人的函数，第二个借用别人的上下文环境。） 如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。</p>
<p>用括号的第一个参数来代替this的指向</p>
<p>call（） 就是用来让括号里的对象 来集成括号外的函数的属性！可以称之为继承！</p>
<p>apply方法：</p>
<p>语法：apply([thisObj[,argArray]])</p>
<p>定义：应用某一对象的一个方法，用另一个对象替换当前对象。</p>
<p>说明：</p>
<p>如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。</p>
<p>如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数</p>
<p>作用相同，只是书写格式不同</p>
<h2 id="call方法案例"><a href="#call方法案例" class="headerlink" title="call方法案例"></a><a id="call_24"></a>call方法案例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alert(a+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a,b</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    alert(a-b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(sub,<span class="number">3</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>个人理解call和apply的作用就是切换函数的对象上下文。</p>
<p> “这个例子中的意思就是用 add 来替换 sub“，应该是将add执行的上下文由window切换为sub，即this指向是从window变为sub，仅此而已，并非add替换sub。这个例子很难说明什么。</p>
<p> 其实就是call方法前面的东西(add)都交给后面(sub)了，就像兄弟，接过这把枪。</p>
<p>add.call(sub,3,1) // sub 已经接过了add方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"Animal"</span>;    </span><br><span class="line"><span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">alert(<span class="keyword">this</span>.name);    </span><br><span class="line"> &#125;    </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line"> <span class="keyword">this</span>.name = <span class="string">"Cat"</span>;    </span><br><span class="line">&#125;      </span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();    </span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入结果为"Cat"</span></span><br><span class="line"></span><br><span class="line">animal.showName.call(cat,<span class="string">","</span>);</span><br><span class="line"></span><br><span class="line">animal.showName.apply(cat,[]);</span><br></pre></td></tr></table></figure></p>
<p>call 的意思是把 animal 的方法放到cat上执行，原来cat是没有showName() 方法，现在是把animal 的showName()方法放到 cat上来执行，所以this.name 应该是 Cat。</p>
<p>call和apply函数功能是一样的；就是参数格式不同；fun.call(obj， arguments)；apply的arguments是数组形式；call则是单数形式。</p>
<h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a><a id="bind_146"></a>bind()方法</h2><p>bind与前两个不同，前两个是改变this的指向，而bind是绑定this的指向，返回的是一个this指向为你所绑定的一个新函数，而原本的函数并没有改变。并且，call和apply改变this指向时会自动调用此函数，但bind不会，需要手动去调用并传参。如果在绑定this指向时传参，那参数的值就不能再改变。</p>
<p><strong>语法</strong></p>
<p>bind（this指向）</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/js/">js</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2019 yan</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>