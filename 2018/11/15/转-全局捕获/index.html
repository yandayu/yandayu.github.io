<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="yan"><meta name="keywords" content="闫大雨，前端，博客"><meta name="description" content="个人博客"><link rel="alternative" href="/atom.xml" title="Hey 这里是闫大雨" type="application/atom+xml"><link rel="icon" href="/img/h2.gif"><title>[转]全局捕获 - Hey 这里是闫大雨</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">Hey 这里是闫大雨</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-11-15T01:15:18.000Z">十一月 15, 2018</time><h1 class="post__title"><a href="/2018/11/15/转-全局捕获/">[转]全局捕获</a></h1><div class="post__main echo"><p>全局捕获只支持鼠标事件，不支持键盘事件。</p>
<p>全局捕获： 全局（包含浏览器外）出现一个鼠标事件，会被设置全局捕获的对象捕获，如果此对象正好有对应的事件函数，</p>
<p>那么会被触发，而最初的发起事件的元素就不会执行它的事件函数了，通俗点说就是事件被掠走了。</p>
<p>全局捕获只能执行一次捕获的事件，如果持续捕获可能会出现问题，可以想象下：</p>
<p>如果全局捕获点击事件，鼠标无论点击哪里都会执行那段代码，那么连最基本的关闭浏览器窗口都不行了。</p>
<p>如果持续捕获，必须有取消全局捕获。</p>
<hr>
<p>作者：jerny2017</p>
<p>来源：CSDN</p>
<p>原文：<a href="https://blog.csdn.net/jerny2017/article/details/80282502" target="_blank" rel="noopener">https://blog.csdn.net/jerny2017/article/details/80282502</a></p>
<p>setCapture函数的作用就是将后续的mouse事件都发送给这个对象，releaseCapture就是将鼠标事件还回去，由 document、window、object之类的自行来处理。这样就保证了在拖动的过程中，不会由于经过了其它的元素而受到干扰</p>
<p>另外，还有一个很重 要的事情是，在Win32上，mouse move的事件不是一个连续的，也就是说，并不是我们每次移动1px的鼠标指针，就会发生一个mousemove，windows会周期性检查mouse 的位置变化来产生mousemove的事件。</p>
<p>所以，如果是一个很小的页面对象，比如一个直径5px的圆点，如果没有setCapture和 releaseCapture，那么在鼠标按住之后，快速的移动鼠标，就有可能鼠标移动走了，但是小圆点还在原地，就是因为下一次的mousemove事 件已经不再发给这个圆点对象了。</p>
<p>web开发和windows开发最大的区别就是windows开发是有状态的，而web开发是无状态的，在windows中，一切操作都可以由程序来控制 ，除非强制执行ctrl+alt+del；但web操作就不一样了，即使执行很重要的操作，用户一点击浏览器关闭按钮，就将前面操作成果化为乌有.尽管可以在onunload事件中加些代码，让用户可以选择是否退出，但不能从根本上解决问题!</p>
<p>前几天，从网上看到setCapture方法，了解了一下，大体是这样的意思，当在IE文档某个区域中使用了这个方法，并且写了onclick或者 onmouse***等有关的鼠标事件方法，那么它就会监视相应的鼠标操作，即使你的鼠标移出了IE，它也一样能捕获到.如果你在某div中的 onclick事件中写了一个alert命令，这时，你点击的关闭按钮，它也一样会弹出alert窗口.releaseCapture与 setCapture方法相反，释放鼠标监控.</p>
<p>利用这个特性，我们可以延缓IE的关闭窗口等破坏性操作，将一些重要的操作能够在破坏性操作执行之前得到处理.</p>
<p>有一点遗憾:setCapture和releaseCapture 不支持键盘事件.只对onmousedown， onmouseup， onmousemove， onclick， ondblclick， onmouseover， onmouseout这样的鼠标事件起作用.</p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/js/">js</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2019 yan</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>