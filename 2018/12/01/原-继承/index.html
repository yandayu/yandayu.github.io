<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="yan"><meta name="keywords" content="闫大雨，前端，博客"><meta name="description" content="个人博客"><link rel="alternative" href="/atom.xml" title="Hey 这里是闫大雨" type="application/atom+xml"><link rel="icon" href="/img/h2.gif"><title>[原]继承 - Hey 这里是闫大雨</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">Hey 这里是闫大雨</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-12-01T09:08:10.000Z">十二月 1, 2018</time><h1 class="post__title"><a href="/2018/12/01/原-继承/">[原]继承</a></h1><div class="post__main echo"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><a id="_0"></a>定义</h2><p>面向对象的特性：封装，继承，多态。</p>
<p>继承是类与类之间的关系，在面向对象的语言中是为了多态服务的。而js不是一门面向对象的语言，没有类的概念，但是我们可以模拟面向对象，模拟继承。继承是一种父类级别与子类级别的关系。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a><a id="_4"></a>方法</h2><p>1、原型继承—-&gt;改变原型的指向</p>
<p><em>原型的作用是数据共享，目的是为了节省内存空间，那么在这我们可以知道原型的另一个作用：继承。所以，继承的作用也是为了节省内存空间。</em></p>
<p>缺陷：因为在改变原型指向的同时初始化了属性，那么继承的属性值都是相同的，只能调用对象的属性重新赋值，这样就</p>
<p>太过于浪费时间了。</p>
<p>2、借用构造函数继承 —&gt; call()方法</p>
<p>缺陷：不会继承原型中添加的方法</p>
<p>3、组合继承 —&gt; 原型继承+借用构造函数继承            改变指向时不初始化属性，既解决了属性问题又解决了方法问题。</p>
<p>4、拷贝继承 —&gt; 把需要共享的属性及方法，通过for in遍历的方式复制到另一个属性中</p>
<p><strong>补充</strong></p>
<p>5、对象继承 —&gt; 可以使用这种方法创建对象，同时指定新对象的原型指向，并且可以设置属性的特性，较为灵活。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.creat(要指向的原型，&#123;</span><br><span class="line">         属性值：&#123;</span><br><span class="line">         value：值，</span><br><span class="line">         enumerable:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">         configurable:<span class="literal">true</span>/<span class="literal">false</span>,</span><br><span class="line">         writable:<span class="literal">true</span>/<span class="literal">false</span></span><br><span class="line">         &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/js/">js</a></li></ul></footer></article><div class="comments" id="lv-container" data-id="city" data-uid="your uid"><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2019 yan</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>